<?xml version="1.0"?>
<doc>
    <assembly>
        <name>SnowLibrary</name>
    </assembly>
    <members>
        <member name="T:SnowLibrary.ConsoleExtentions.Input">
            <summary>
            Allows for easy key input gathering from console applications
            </summary>
        </member>
        <member name="M:SnowLibrary.ConsoleExtentions.Input.GetKey(System.ConsoleKey,System.Boolean,System.Boolean)">
            <summary>
            gets the specified key. using intercept to determain if the pressed key should appear in the console.
            </summary>
            <param name="key"></param>
            <param name="intercept"></param>
            <param name="wait"></param>
            <returns>returns true when the key is pressed. otherwise, if wait is set to false and the key is not being pressed, it returns false</returns>
        </member>
        <member name="T:SnowLibrary.ConsoleExtentions.ConsoleS">
            <summary>
            Extra stuff for console applications
            </summary>
        </member>
        <member name="M:SnowLibrary.ConsoleExtentions.ConsoleS.WriteErrorLine``1(``0)">
            <summary>
            Writes a red text line with slight indent to the console
            </summary>
            <typeparam name="T"></typeparam>
            <param name="Message"></param>
        </member>
        <member name="M:SnowLibrary.ConsoleExtentions.ConsoleS.WriteError``1(``0)">
            <summary>
            Writes the red text to the console with a tab before it
            </summary>
            <typeparam name="T"></typeparam>
            <param name="Message"></param>
        </member>
        <member name="M:SnowLibrary.ConsoleExtentions.ConsoleS.WriteWarningLine``1(``0)">
            <summary>
            Writes a yellow text line with slight indent to the console
            </summary>
            <typeparam name="T"></typeparam>
            <param name="Message"></param>
        </member>
        <member name="M:SnowLibrary.ConsoleExtentions.ConsoleS.WriteWarning``1(``0)">
            <summary>
            Writes the yellow text to the console with a tab before it
            </summary>
            <typeparam name="T"></typeparam>
            <param name="Message"></param>
        </member>
        <member name="T:SnowLibrary.ConsoleExtentions.WindowFlasher">
            <summary>
            Allows for flashing of Console Windows
            </summary>
        </member>
        <member name="F:SnowLibrary.ConsoleExtentions.WindowFlasher.FLASHWINFO.cbSize">
            <summary>
            The size of the structure, in bytes
            </summary>
        </member>
        <member name="F:SnowLibrary.ConsoleExtentions.WindowFlasher.FLASHWINFO.hwnd">
            <summary>
            A handle to the window to be flashed. The window can be either opened or minimized.
            </summary>
        </member>
        <member name="F:SnowLibrary.ConsoleExtentions.WindowFlasher.FLASHWINFO.dwFlags">
            <summary>
            The flash status. This parameter can be one or more of the following values.
            </summary>
        </member>
        <member name="F:SnowLibrary.ConsoleExtentions.WindowFlasher.FLASHWINFO.uCount">
            <summary>
            The number of times to flash the window.
            </summary>
        </member>
        <member name="F:SnowLibrary.ConsoleExtentions.WindowFlasher.FLASHWINFO.dwTimeout">
            <summary>
            The rate at which the window is to be flashed, in milliseconds. If dwTimeout is zero, the function uses the default cursor blink rate.
            </summary>
        </member>
        <member name="F:SnowLibrary.ConsoleExtentions.WindowFlasher.FLASHW_ALL">
            <summary>
            Flash both the window caption and taskbar button. This is equivalent to setting the FLASHW_CAPTION | FLASHW_TRAY flags.
            </summary>
        </member>
        <member name="F:SnowLibrary.ConsoleExtentions.WindowFlasher.FLASHW_STOP">
            <summary>
            Stop flashing. The system restores the window to its original state.
            </summary>
        </member>
        <member name="M:SnowLibrary.ConsoleExtentions.WindowFlasher.GetFLASHWINFO(System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Create an instance of the FLASHWINFO structure
            </summary>
            <param name="flashwConstant">One of the provided FLASHW contant values</param>
            <param name="uCount">uCount to initialize the struct</param>
            <param name="dwTimeout">dwTimeout to initalize the struct</param>
            <returns>A fully instantiated FLASHWINFO struct</returns>
        </member>
        <member name="M:SnowLibrary.ConsoleExtentions.WindowFlasher.Flash(System.UInt32)">
            <summary>
            Flashes the console window (continues indefinitely)
            </summary>
        </member>
        <member name="M:SnowLibrary.ConsoleExtentions.WindowFlasher.StopFlash">
            <summary>
            Stops the flashing of the console window
            </summary>
        </member>
        <member name="T:SnowLibrary.Encryption.Encrypter">
            <summary>
            Encrypt strings with special incrytion settings
            </summary>
        </member>
        <member name="F:SnowLibrary.Encryption.Encrypter.SupportedCharacters">
            <summary>
            Represents a string literal that shows all supported characters by the encrypter
            </summary>
        </member>
        <member name="M:SnowLibrary.Encryption.Encrypter.#ctor(SnowLibrary.Encryption.EncrypterSetting,SnowLibrary.Encryption.EncrypterSetting,SnowLibrary.Encryption.EncrypterSetting)">
            <summary>
            Creates a new instance of the Encrypter class
            </summary>
            <param name="setting1"></param>
            <param name="setting2"></param>
            <param name="setting3"></param>
        </member>
        <member name="M:SnowLibrary.Encryption.Encrypter.Encrypt(System.String)">
            <summary>
            encrypts the given message.
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:SnowLibrary.Encryption.Encrypter.Decrypt(System.String)">
            <summary>
            Decrypts the given message
            </summary>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="T:SnowLibrary.Encryption.EncrypterSetting">
            <summary>
            this class is part of the Encryption, 
            </summary>
        </member>
        <member name="M:SnowLibrary.Encryption.EncrypterSetting.#ctor(SnowLibrary.Encryption.ScrambleConfiguration,System.Int32,System.Int32)">
            <summary>
            creates a new instance of the Rotor class
            </summary>
            <param name="configuration">Selects which config is chosen for this specific rotor</param>
            <param name="offset">indicates at what position the rotor starts at</param>
            <param name="moveNext">at what rotation of this rotor should it signal the rotation of the next</param>
        </member>
        <member name="T:SnowLibrary.Encryption.ScrambleConfiguration">
            <summary>
            Makes for easy determaining what rotor configuration to choose from
            </summary>
        </member>
        <member name="F:SnowLibrary.Encryption.ScrambleConfiguration.I">
            <summary>
            Represents the first configuration of the rotors
            </summary>
        </member>
        <member name="F:SnowLibrary.Encryption.ScrambleConfiguration.II">
            <summary>
            Represents the second configuration of the rotors
            </summary>
        </member>
        <member name="F:SnowLibrary.Encryption.ScrambleConfiguration.III">
            <summary>
            Represents the third configuration of the rotors
            </summary>
        </member>
        <member name="F:SnowLibrary.Encryption.ScrambleConfiguration.IV">
            <summary>
            Represents the fourth configuration of the rotors
            </summary>
        </member>
        <member name="F:SnowLibrary.Encryption.ScrambleConfiguration.V">
            <summary>
            Represents the fifth configuration of the rotors
            </summary>
        </member>
        <member name="T:SnowLibrary.FileManagement.FileManager">
            <summary>
            Allows for easy file manipulation. For suggestions please relay them to <b>TheSnowOwl</b>
            </summary>
        </member>
        <member name="M:SnowLibrary.FileManagement.FileManager.Write(System.String,System.String,System.Boolean)">
            <summary>
            Write a given string to a text file. include the .txt in the path. Method creates new file and directory if either does not exists.
            </summary>
        </member>
        <member name="M:SnowLibrary.FileManagement.FileManager.WriteLine(System.String,System.String,System.Boolean)">
            <summary>
            Write a given string to a text file on a new line. include the .txt in the path. Method creates new file and directory if either does not exists.
            </summary>
            <param name="path"></param>
            <param name="content"></param>
            <param name="overrideFile"></param>
        </member>
        <member name="M:SnowLibrary.FileManagement.FileManager.Read(System.String)">
            <summary>
            Reads all text from the FileStream from beginning to end
            </summary>
            <returns>one conplete string of all text in the file</returns>
            <exception cref="T:System.IO.FileNotFoundException"></exception>
        </member>
        <member name="M:SnowLibrary.FileManagement.FileManager.TryRead(System.String)">
            <summary>
            attempts to read the given file
            </summary>
            <param name="path"></param>
            <returns>if the given file does not exist, or is already used, returns null</returns>
        </member>
        <member name="M:SnowLibrary.FileManagement.FileManager.ReadLine(System.String,System.Int32)">
            <summary>
            reads the specified line
            </summary>
            <param name="path"></param>
            <param name="lineNumber"></param>
            <returns>the string that exists on the specified line</returns>
            <exception cref="T:System.IO.FileNotFoundException"></exception>
            <exception cref="T:SnowLibrary.FileManagement.LineNumberTooGreatException"></exception>
        </member>
        <member name="M:SnowLibrary.FileManagement.FileManager.ReadAllLines(System.String)">
            <summary>
            reads all lines in the file
            </summary>
            <param name="path"></param>
            <returns>a string array of all lines</returns>
            <exception cref="T:System.IO.FileNotFoundException"></exception>
        </member>
        <member name="M:SnowLibrary.FileManagement.FileManager.WriteAsync(System.String,System.String,System.Boolean)">
            <summary>
            Write a given string to a text file. include the .txt in the path. Method creates new file and directory if either does not exists.
            </summary>
        </member>
        <member name="M:SnowLibrary.FileManagement.FileManager.WriteLineAsync(System.String,System.String,System.Boolean)">
            <summary>
            Write a given string to a text file on a new line. include the .txt in the path. Method creates new file and directory if either does not exists.
            </summary>
            <param name="path"></param>
            <param name="content"></param>
            <param name="overrideFile"></param>
        </member>
        <member name="M:SnowLibrary.FileManagement.FileManager.ReadAsync(System.String)">
            <summary>
            Reads all text from the FileStream from beginning to end
            </summary>
            <returns>one conplete string of all text in the file</returns>
            <exception cref="T:System.IO.FileNotFoundException"></exception>
        </member>
        <member name="M:SnowLibrary.FileManagement.FileManager.ReadLineAsync(System.String,System.Int32)">
            <summary>
            reads the specified line
            </summary>
            <param name="path"></param>
            <param name="lineNumber"></param>
            <returns>the string that exists on the specified line</returns>
            <exception cref="T:System.IO.FileNotFoundException"></exception>
            <exception cref="T:SnowLibrary.FileManagement.LineNumberTooGreatException"></exception>
        </member>
        <member name="M:SnowLibrary.FileManagement.FileManager.ReadAllLinesAsync(System.String)">
            <summary>
            reads all lines in the file
            </summary>
            <param name="path"></param>
            <returns>a string array of all lines</returns>
            <exception cref="T:System.IO.FileNotFoundException"></exception>
        </member>
        <member name="M:SnowLibrary.FileManagement.FileManager.ZipDirectory(System.String,System.String,System.IO.Compression.CompressionLevel,System.Boolean)">
            <summary>
            Zips the given directory, and places the created zip file in the given destination path
            </summary>
            <param name="sourceDirectory"></param>
            <param name="archiveDestinationPath"></param>
            <param name="compressionLevel"></param>
            <param name="overrideExistingFile"></param>
        </member>
        <member name="M:SnowLibrary.FileManagement.FileManager.UnzipDirectory(System.String,System.String,System.Boolean)">
            <summary>
            unzips the given archive, and places the resulting directory at the given path
            </summary>
            <param name="sourceArchive"></param>
            <param name="destinationDirectoryPath"></param>
            <param name="overrideFiles"></param>
        </member>
        <member name="T:SnowLibrary.FileManagement.FileOutput">
            <summary>
            Represents the output from a read action from the SnowLibrary. this class can be directly assigned to and from a string. no casting needed.
            </summary>
        </member>
        <member name="M:SnowLibrary.FileManagement.FileOutput.#ctor(System.String)">
            <summary>
            Creates a new instance of the FileOutput class that contains a populated string
            </summary>
            <param name="s"></param>
        </member>
        <member name="M:SnowLibrary.FileManagement.FileOutput.#ctor">
            <summary>
            Creates a new instance of the FileOutput class that contains an empty string
            </summary>
        </member>
        <member name="M:SnowLibrary.FileManagement.FileOutput.RemoveReadAnomalies">
            <summary>
            Removes any and all <b>\r\n</b> that contain within the FileOutput, then returns it as a string
            </summary>
            <returns></returns>
        </member>
        <member name="M:SnowLibrary.FileManagement.FileOutput.op_Implicit(SnowLibrary.FileManagement.FileOutput)~System.String">
            <summary>
            Get the output value as a string
            </summary>
            <param name="f"></param>
        </member>
        <member name="M:SnowLibrary.FileManagement.FileOutput.op_Implicit(System.String)~SnowLibrary.FileManagement.FileOutput">
            <summary>
            Get a new FileOutput instance from a given string
            </summary>
            <param name="s"></param>
        </member>
        <member name="T:SnowLibrary.FileManagement.FileOutputExtensions">
            <summary>
            A class containing helpfull methods for FileOutput handling
            </summary>
        </member>
        <member name="M:SnowLibrary.FileManagement.FileOutputExtensions.RemoveReadAnomalies(SnowLibrary.FileManagement.FileOutput[])">
            <summary>
            Removes the Read anomalies from every FileOutput within the array
            </summary>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:SnowLibrary.FileManagement.FileOutputExtensions.ToStringArray(SnowLibrary.FileManagement.FileOutput[])">
            <summary>
            turns the complete FileOutput array into a array of strings
            </summary>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:SnowLibrary.FileManagement.FileOutputExtensions.ToFileOutputArray(System.String[])">
            <summary>
            Creates an array of FileOutput classes from an array of strings
            </summary>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="T:SnowLibrary.FileManagement.LineNumberTooGreatException">
            <summary>
            Gets thrown when reading for a specific line which does not exist in the given file
            </summary>
        </member>
        <member name="T:SnowLibrary.SnowMathExtentionMethods">
            <summary>
            Math Extention Methods for all Snow needs
            </summary>
        </member>
        <member name="M:SnowLibrary.SnowMathExtentionMethods.FloorToInt(System.Double)">
            <summary>
            floors the given double to the nearest integer
            </summary>
            <param name="num">This number will be converted to an integer</param>
            <returns>an integer floored from to the nearest possible whole number</returns>
        </member>
        <member name="M:SnowLibrary.SnowMathExtentionMethods.FloorToInt(System.Single)">
            <summary>
            floors the given float to the nearest integer
            </summary>
            <param name="num">This number will be converted to an integer</param>
            <returns>an integer floored from to the nearest possible whole number</returns>
        </member>
        <member name="M:SnowLibrary.SnowMathExtentionMethods.CeilingToInt(System.Double)">
            <summary>
            Raises the given double to the nearest integer
            </summary>
            <param name="num">This number will be converted to an integer</param>
            <returns>an integer raised from to the nearest possible whole number</returns>
        </member>
        <member name="M:SnowLibrary.SnowMathExtentionMethods.CeilingToInt(System.Single)">
            <summary>
            Raises the given float to the nearest integer
            </summary>
            <param name="num">This number will be convertd to an integer</param>
            <returns>an integer raised from to the nearest possible whole number</returns>
        </member>
        <member name="M:SnowLibrary.SnowMathExtentionMethods.FloorToInt(System.Decimal)">
            <summary>
            floors the given decumal to the nearest round integer
            </summary>
            <param name="num"></param>
            <returns>the floored number</returns>
        </member>
        <member name="M:SnowLibrary.SnowMathExtentionMethods.CeilingToInt(System.Decimal)">
            <summary>
            Raises the given decimal to the nearest round integer
            </summary>
            <param name="num"></param>
            <returns>the raised number</returns>
        </member>
        <member name="M:SnowLibrary.SnowMathExtentionMethods.ConsecutiveNumbers(System.Collections.Generic.List{System.Int32},System.Int32)">
            <summary>
            Generates a list of numbers starting at 0 up to count - 1
            </summary>
            <param name="nums"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="T:SnowLibrary.MathS">
            <summary>
            All extra Math methods Snow needs
            </summary>
        </member>
        <member name="M:SnowLibrary.MathS.FloorToInt(System.Double)">
            <summary>
            Floors the given double to the nearest integer
            </summary>
            <param name="num">This number will be converted to an integer</param>
            <returns>an integer floored from to the nearest possible integer</returns>
        </member>
        <member name="M:SnowLibrary.MathS.FloorToInt(System.Single)">
            <summary>
            Floors the given float to the nearest integer
            </summary>
            <param name="num">This number will be converted to an integer</param>
            <returns>an integer floored from to the nearest possible integer</returns>
        </member>
        <member name="M:SnowLibrary.MathS.CeilingToInt(System.Double)">
            <summary>
            Raises the given double to the nearest integer
            </summary>
            <param name="num">This number will be converted to an integer</param>
            <returns>an integer raised from to the nearest possible integer</returns>
        </member>
        <member name="M:SnowLibrary.MathS.CeilingToInt(System.Single)">
            <summary>
            Raises the given float to the nearest integer
            </summary>
            <param name="num">This number will be convertd to an integer</param>
            <returns>an integer raised from to the nearest possible integer</returns>
        </member>
        <member name="M:SnowLibrary.MathS.FloorToInt(System.Decimal)">
            <summary>
            floors the given decumal to the nearest round integer
            </summary>
            <param name="num"></param>
            <returns>the floored number</returns>
        </member>
        <member name="M:SnowLibrary.MathS.CeilingToInt(System.Decimal)">
            <summary>
            Raises the given decimal to the nearest round integer
            </summary>
            <param name="num"></param>
            <returns>the raised number</returns>
        </member>
        <member name="M:SnowLibrary.MathS.GetHexadecimal(System.Int32)">
            <summary>
            Gets the hexadecimal value from the given int
            </summary>
            <param name="num"></param>
            <returns></returns>
        </member>
        <member name="M:SnowLibrary.MathS.GetNumber(System.String)">
            <summary>
            gets the integer value from the given hexadecimal
            </summary>
            <param name="hexadecimal"></param>
            <returns></returns>
        </member>
        <member name="M:SnowLibrary.MathS.GetPersentage(System.Double,System.Double,System.Int32)">
            <summary>
            Get the persentage based on the given parameters
            </summary>
            <param name="current"></param>
            <param name="max"></param>
            <param name="decimals"></param>
            <returns>the persentage calculated from the given parameters</returns>
        </member>
        <member name="M:SnowLibrary.MathS.GetPersentage(System.Int32,System.Double,System.Int32)">
            <summary>
            Get the persentage based on the given parameters
            </summary>
            <param name="current"></param>
            <param name="max"></param>
            <param name="decimals"></param>
            <returns>the persentage calculated from the given parameters</returns>
        </member>
        <member name="M:SnowLibrary.MathS.GetPersentage(System.Double,System.Int32,System.Int32)">
            <summary>
            Get the persentage based on the given parameters
            </summary>
            <param name="current"></param>
            <param name="max"></param>
            <param name="decimals"></param>
            <returns>the persentage calculated from the given parameters</returns>
        </member>
        <member name="M:SnowLibrary.MathS.GetPersentage(System.Single,System.Single,System.Int32)">
            <summary>
            Get the persentage based on the given parameters
            </summary>
            <param name="current"></param>
            <param name="max"></param>
            <param name="decimals"></param>
            <returns>the persentage calculated from the given parameters</returns>
        </member>
        <member name="M:SnowLibrary.MathS.GetPersentage(System.Single,System.Double,System.Int32)">
            <summary>
            Get the persentage based on the given parameters
            </summary>
            <param name="current"></param>
            <param name="max"></param>
            <param name="decimals"></param>
            <returns>the persentage calculated from the given parameters</returns>
        </member>
        <member name="M:SnowLibrary.MathS.GetPersentage(System.Double,System.Single,System.Int32)">
            <summary>
            Get the persentage based on the given parameters
            </summary>
            <param name="current"></param>
            <param name="max"></param>
            <param name="decimals"></param>
            <returns>the persentage calculated from the given parameters</returns>
        </member>
        <member name="M:SnowLibrary.MathS.GetPersentage(System.Int32,System.Single,System.Int32)">
            <summary>
            Get the persentage based on the given parameters
            </summary>
            <param name="current"></param>
            <param name="max"></param>
            <param name="decimals"></param>
            <returns>the persentage calculated from the given parameters</returns>
        </member>
        <member name="M:SnowLibrary.MathS.GetPersentage(System.Single,System.Int32,System.Int32)">
            <summary>
            Get the persentage based on the given parameters
            </summary>
            <param name="current"></param>
            <param name="max"></param>
            <param name="decimals"></param>
            <returns>the persentage calculated from the given parameters</returns>
        </member>
        <member name="M:SnowLibrary.MathS.GetPersentage(System.Int32,System.Int32,System.Int32)">
            <summary>
            Get the persentage based on the given parameters
            </summary>
            <param name="current"></param>
            <param name="max"></param>
            <param name="decimals"></param>
            <returns>the persentage calculated from the given parameters</returns>
        </member>
        <member name="T:SnowLibrary.ActionQueuer">
            <summary>
            Allows for queueing of Methods with no arguments and no return values.
            </summary>
        </member>
        <member name="P:SnowLibrary.ActionQueuer.Count">
            <summary>
            Gets the number of methods in the queue
            </summary>
        </member>
        <member name="M:SnowLibrary.ActionQueuer.#ctor">
            <summary>
            Creates a new instance of the ActionQueuer class
            </summary>
        </member>
        <member name="M:SnowLibrary.ActionQueuer.Add(System.Action)">
            <summary>
            Adds a new action to the queue
            </summary>
            <param name="action">The action that will be added</param>
        </member>
        <member name="M:SnowLibrary.ActionQueuer.StartQueue">
            <summary>
            Starts the queue
            </summary>
            <returns>The completed task</returns>
        </member>
        <member name="T:SnowLibrary.ActionQueuer`1">
            <summary>
            allows for queueing of Methods with one argument and no return values.
            </summary>
            <typeparam name="T1">Argument 1</typeparam>
        </member>
        <member name="M:SnowLibrary.ActionQueuer`1.#ctor">
            <summary>
            Creates a new instance of the ActionQueuer class
            </summary>
        </member>
        <member name="P:SnowLibrary.ActionQueuer`1.Count">
            <summary>
            Gets the number of methods in the queue
            </summary>
        </member>
        <member name="M:SnowLibrary.ActionQueuer`1.Add(SnowLibrary.ActionQueuer{`0}.QueueArgumentCarrier)">
            <summary>
            Adds a new action to the queue
            </summary>
            <param name="argument">The action that will be added, alongside its argument</param>
        </member>
        <member name="M:SnowLibrary.ActionQueuer`1.StartQueue">
            <summary>
            Starts the queue
            </summary>
            <returns>The completed task</returns>
        </member>
        <member name="T:SnowLibrary.ActionQueuer`1.QueueArgumentCarrier">
            <summary>
            allows for the carrying of arguments to actions in the queue
            </summary>
        </member>
        <member name="M:SnowLibrary.ActionQueuer`1.QueueArgumentCarrier.#ctor(System.Action{`0},`0)">
            <summary>
            Creates a new instance of the <b>QueueArgumentCarrier</b> class
            </summary>
            <param name="action"></param>
            <param name="argument"></param>
        </member>
        <member name="M:SnowLibrary.ActionQueuer`1.QueueArgumentCarrier.op_Implicit(SnowLibrary.ActionQueuer{`0}.QueueArgumentCarrier)~`0">
            <summary>
            Gets the arguments value
            </summary>
            <param name="argument"></param>
        </member>
        <member name="T:SnowLibrary.ActionQueuer`2">
            <summary>
            allows for queueing of Methods with two arguments, and no return types. Contact the author of this library if you wish to use more arguments
            </summary>
            <typeparam name="T1">argument 1</typeparam>
            <typeparam name="T2">argument 2</typeparam>
        </member>
        <member name="P:SnowLibrary.ActionQueuer`2.Count">
            <summary>
            Gets the number of methods in the queue
            </summary>
        </member>
        <member name="M:SnowLibrary.ActionQueuer`2.#ctor">
            <summary>
            Creates a new instance of the ActionQueuer class
            </summary>
        </member>
        <member name="M:SnowLibrary.ActionQueuer`2.Add(SnowLibrary.ActionQueuer{`0,`1}.QueueArgumentCarrier)">
            <summary>
            Adds a new action to the queue
            </summary>
            <param name="arguments">The action that will be added, alongside its argument</param>
        </member>
        <member name="M:SnowLibrary.ActionQueuer`2.StartQueue">
            <summary>
            Starts the queue
            </summary>
            <returns>The completed task</returns>
        </member>
        <member name="T:SnowLibrary.ActionQueuer`2.QueueArgumentCarrier">
            <summary>
            Allows for the carrying of a Action with arguments
            </summary>
        </member>
        <member name="M:SnowLibrary.ActionQueuer`2.QueueArgumentCarrier.#ctor(System.Action{`0,`1},`0,`1)">
            <summary>
            allows for the carrying of arguments to actions in the queue
            </summary>
        </member>
        <member name="M:SnowLibrary.ActionQueuer`2.QueueArgumentCarrier.op_Implicit(SnowLibrary.ActionQueuer{`0,`1}.QueueArgumentCarrier)~`0">
            <summary>
            Gets the first argument
            </summary>
            <param name="argument"></param>
        </member>
        <member name="M:SnowLibrary.ActionQueuer`2.QueueArgumentCarrier.op_Implicit(SnowLibrary.ActionQueuer{`0,`1}.QueueArgumentCarrier)~`1">
            <summary>
            Gets the second argument
            </summary>
            <param name="argument"></param>
        </member>
        <member name="T:SnowLibrary.FuncQueuer`1">
            <summary>
            allows for queueing of Methods with no arguments and a return value
            </summary>
            <typeparam name="TReturnType">Return value</typeparam>
        </member>
        <member name="P:SnowLibrary.FuncQueuer`1.Count">
            <summary>
            Gets the number of methods in the queue
            </summary>
        </member>
        <member name="M:SnowLibrary.FuncQueuer`1.#ctor">
            <summary>
            Creates a new instance of the FuncQueuer class
            </summary>
        </member>
        <member name="M:SnowLibrary.FuncQueuer`1.Add(SnowLibrary.FuncQueuer{`0}.QueueFuncArgumentCarrier)">
            <summary>
            Adds the given Func to the queue
            </summary>
            <param name="arguments">the func that will be added, along side its callback action</param>
        </member>
        <member name="M:SnowLibrary.FuncQueuer`1.StartQueue(System.Boolean)">
            <summary>
            Starts the queue
            </summary>
            <param name="waitForCallback"></param>
            <returns>The completed task</returns>
        </member>
        <member name="T:SnowLibrary.FuncQueuer`1.QueueFuncArgumentCarrier">
            <summary>
            Allows for the carrying of a func with a callback action and arguments
            </summary>
        </member>
        <member name="M:SnowLibrary.FuncQueuer`1.QueueFuncArgumentCarrier.#ctor(System.Func{`0},System.Action{`0})">
            <summary>
            Creates a new instance of the <b>QueueFuncArgumentCarrier</b> class
            </summary>
            <param name="func"></param>
            <param name="callBack"></param>
        </member>
        <member name="T:SnowLibrary.FuncQueuer`2">
            <summary>
            allows for queueing of Methods with one argument and a return value.
            </summary>
            <typeparam name="TArgument1">argument 1</typeparam>
            <typeparam name="TReturnType">return value</typeparam>
        </member>
        <member name="P:SnowLibrary.FuncQueuer`2.Count">
            <summary>
            Gets the number of methods currently in the queue
            </summary>
        </member>
        <member name="M:SnowLibrary.FuncQueuer`2.Add(SnowLibrary.FuncQueuer{`0,`1}.QueueFuncArgumentCarrier)">
            <summary>
            adds the specified func with its callback action and its argument to the queue
            </summary>
            <param name="arguments"></param>
        </member>
        <member name="M:SnowLibrary.FuncQueuer`2.StartQueue">
            <summary>
            Starts the queue
            </summary>
            <returns>The Completed Task</returns>
        </member>
        <member name="T:SnowLibrary.FuncQueuer`2.QueueFuncArgumentCarrier">
            <summary>
            Allows for the carrying of a func with a callback action and arguments
            </summary>
        </member>
        <member name="M:SnowLibrary.FuncQueuer`2.QueueFuncArgumentCarrier.#ctor(System.Func{`0,`1},`0,System.Action{`1})">
            <summary>
            Creates a new instance of the <b>QueueFuncArgumentCarrier</b> class
            </summary>
            <param name="func"></param>
            <param name="callBack"></param>
        </member>
        <member name="M:SnowLibrary.FuncQueuer`2.QueueFuncArgumentCarrier.op_Implicit(SnowLibrary.FuncQueuer{`0,`1}.QueueFuncArgumentCarrier)~`0">
            <summary>
            Gets the argument
            </summary>
            <param name="argument"></param>
        </member>
        <member name="T:SnowLibrary.FuncQueuer`3">
            <summary>
            Contact the author of this library if you wish to use more arguments
            </summary>
            <typeparam name="TArgument1">argument 1</typeparam>
            <typeparam name="TArgument2">argument 2</typeparam>
            <typeparam name="TReturnType">return value</typeparam>
        </member>
        <member name="P:SnowLibrary.FuncQueuer`3.Count">
            <summary>
            Gets the number of methods currently in the queue
            </summary>
        </member>
        <member name="M:SnowLibrary.FuncQueuer`3.#ctor">
            <summary>
            Creates a new instance of the FuncQueuer class
            </summary>
        </member>
        <member name="M:SnowLibrary.FuncQueuer`3.Add(SnowLibrary.FuncQueuer{`0,`1,`2}.QueueFuncArgumentCarrier)">
            <summary>
            Adds the given func with its callback action and arguments to the queue
            </summary>
            <param name="arguments"></param>
        </member>
        <member name="M:SnowLibrary.FuncQueuer`3.StartQueue">
            <summary>
            Starts the queue
            </summary>
            <returns>The completed task</returns>
        </member>
        <member name="T:SnowLibrary.FuncQueuer`3.QueueFuncArgumentCarrier">
            <summary>
            Allows for the carrying of a func with a callback action and arguments
            </summary>
        </member>
        <member name="M:SnowLibrary.FuncQueuer`3.QueueFuncArgumentCarrier.#ctor(System.Func{`0,`1,`2},`0,`1,System.Action{`2})">
            <summary>
            Creates a new instance of the FuncQueuer class
            </summary>
        </member>
        <member name="M:SnowLibrary.FuncQueuer`3.QueueFuncArgumentCarrier.op_Implicit(SnowLibrary.FuncQueuer{`0,`1,`2}.QueueFuncArgumentCarrier)~`0">
            <summary>
            Gets the first argument
            </summary>
            <param name="argument"></param>
        </member>
        <member name="M:SnowLibrary.FuncQueuer`3.QueueFuncArgumentCarrier.op_Implicit(SnowLibrary.FuncQueuer{`0,`1,`2}.QueueFuncArgumentCarrier)~`1">
            <summary>
            Gets the second argument
            </summary>
            <param name="argument"></param>
        </member>
        <member name="T:SnowLibrary.Serialization.ExcludeFromSerializationAttribute">
            <summary>
            Makes sure that when serializing or deserializing this field will always be ignore
            </summary>
        </member>
        <member name="T:SnowLibrary.Serialization.IncludeWithSerializationAttribute">
            <summary>
            Tells the serializer to include this property when handling its declaring class
            </summary>
        </member>
        <member name="T:SnowLibrary.Serialization.IncludePrivateFieldsAttribute">
            <summary>
            Tells the serializer to use the private fields within this class or struct even if the passed setting states not to include them
            </summary>
        </member>
        <member name="T:SnowLibrary.Serialization.IncludeAllPropertiesAttribute">
            <summary>
            Tells the serializer to include all properties in the given class or struct even if they do not have the <b>IncludeWithSerializationAttribute</b> attribute
            </summary>
        </member>
        <member name="T:SnowLibrary.Serialization.SnowSerializer">
            <summary>
            Provides methods for the Serializing and Deserializing to and from the Snow-Format. it can be used to save and load data for use after a program reboot
            </summary>
        </member>
        <member name="M:SnowLibrary.Serialization.SnowSerializer.Serialize``1(``0,System.Boolean,System.Boolean)">
            <summary>
            Serialize an object to the Snow-Format. returns a string containing all datafields. Check the README.md provided for supported values. skips and any value with the "ExcludeFromSerialization" attribute
            </summary>
            <returns>a string format containing all data from the given object</returns>
            <exception cref="T:SnowLibrary.Serialization.TypeNotFoundException">thrown when no type corrosponding with a class field is found</exception>
            <exception cref="T:System.Exception">thrown if creation of classfield instance has failed</exception>
            <exception cref="T:SnowLibrary.Serialization.SerializationFailedException">thrown when any error is thrown. holds this thrown error as its inner exception</exception>
        </member>
        <member name="M:SnowLibrary.Serialization.SnowSerializer.SerializeList``1(System.Collections.Generic.List{``0},System.Boolean,System.Boolean,System.Boolean,System.Int32)">
            <summary>
            Serialize a list of objects to the Snow-format. returns a string containing all objects with their datafields. can only nest 2 classes from the base class
            if the amount of items to handle is more than 5000 it uses 4 threads and processes 4 items at once
            if <paramref name="potatoCPU"/> is set to true it will process only 1 object at a time no matter the total objects to be handled. 
            else it will determain the best distribution among the  allowed usable threads and processes multiple at once
            </summary>
            <returns>string containing the data of every object instance in the provided list</returns>
            <exception cref="T:SnowLibrary.Serialization.TypeNotFoundException">thrown when no type corrosponding with a class field is found</exception>
            <exception cref="T:System.Exception">thrown if creation of classfield instance has failed</exception>
            <exception cref="T:SnowLibrary.Serialization.SerializationFailedException">thrown when any error is thrown. holds this thrown error as its inner exception</exception>
        </member>
        <member name="M:SnowLibrary.Serialization.SnowSerializer.SerializeArray``1(``0[],System.Boolean,System.Boolean,System.Boolean,System.Int32)">
            <summary>
            Serialize a array of objects to the Snow-format. returns a string containing all objects with their base C# datatypes
            if <paramref name="potatoCPU"/> is set to true it will process only 1 object at a time no matter the total objects to be handled. 
            else it will determain the best distribution among the  allowed usable threads and processes multiple at once
            </summary>
            <returns>string containing the data of every object instance in the provided array</returns>
            <exception cref="T:SnowLibrary.Serialization.TypeNotFoundException">thrown when no type corrosponding with a class field is found</exception>
            <exception cref="T:System.Exception">thrown if creation of classfield instance has failed</exception>
            <exception cref="T:SnowLibrary.Serialization.SerializationFailedException">thrown when any error is thrown. holds this thrown error as its inner exception</exception>
        </member>
        <member name="M:SnowLibrary.Serialization.SnowSerializer.SerializeList``1(System.Collections.Generic.List{``0},System.Action{SnowLibrary.Serialization.SnowSerializerProgressReporter},System.Int32,System.Boolean,System.Boolean,System.Boolean,System.Int32)">
            <summary>
            Serialize an object to the Snow-Format.
            reports its progress to the given function every given amount of iteration
            if <paramref name="potatoCPU"/> is set to true it will process only 1 object at a time no matter the total objects to be handled. 
            else it will determain the best distribution among the  allowed usable threads and processes multiple at once
            </summary>
            <returns>string containing the data of every object instance in the provided list</returns>
            <exception cref="T:SnowLibrary.Serialization.TypeNotFoundException">thrown when no type corrosponding with a class field is found</exception>
            <exception cref="T:System.Exception">thrown if creation of classfield instance has failed</exception>
            <exception cref="T:SnowLibrary.Serialization.SerializationFailedException">thrown when any error is thrown. holds this thrown error as its inner exception</exception>
        </member>
        <member name="M:SnowLibrary.Serialization.SnowSerializer.SerializeArray``1(``0[],System.Action{SnowLibrary.Serialization.SnowSerializerProgressReporter},System.Int32,System.Boolean,System.Boolean,System.Boolean,System.Int32)">
            <summary>
            Serialize an object to the Snow-Format.
            reports its progress to the given function every given amount of iteration
            if <paramref name="potatoCPU"/> is set to true it will process only 1 object at a time no matter the total objects to be handled. 
            else it will determain the best distribution among the  allowed usable threads and processes multiple at once
            </summary>
            <returns>string containing the data of every object instance in the provided list</returns>
            <exception cref="T:SnowLibrary.Serialization.TypeNotFoundException">thrown when no type corrosponding with a class field is found</exception>
            <exception cref="T:System.Exception">thrown if creation of classfield instance has failed</exception>
            <exception cref="T:SnowLibrary.Serialization.SerializationFailedException">thrown when any error is thrown. holds this thrown error as its inner exception</exception>
        </member>
        <member name="M:SnowLibrary.Serialization.SnowSerializer.Deserialize``1(System.String,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Deserialize a string from the Snow-Format into a C# class object. 
            when 'ignoreNotFoundFields' is true it will not throw an exception when it tries to deserialize a field which does not exist in the given class. the data that was linked to the field will be ignored aswell.
            </summary>
            <returns>the deserialized object with values given from the serialized string</returns>
            <exception cref="T:System.ArgumentNullException">thrown when 'assembly' or 'typeName' are null when working with a classfield object</exception>
            <exception cref="T:SnowLibrary.Serialization.TypeNotFoundException">thrown when no type was found for the classfield object</exception>
            <exception cref="T:SnowLibrary.FailedToCastTypeException">thrown when when the serializer could not cast the string value to the given field type</exception>
            <exception cref="T:SnowLibrary.Serialization.DeserializationFailedException">thrown when any error is thrown. holds this thrown error as its inner exception</exception>
        </member>
        <member name="M:SnowLibrary.Serialization.SnowSerializer.DeserializeList``1(System.String,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Int32)">
            <summary>
            Deserialize a string from the Snow-Format into a list of C# class objects. 
            when 'ignoreNotFoundFields' is true it will not throw an exception when it tries to deserialize a field which does not exist in the given class. the data that was linked to the field will be ignored aswell.
            if <paramref name="potatoCPU"/> is set to true it will make sure to only process one object at a time on a single thread.
            else it will determain the best distribution among the  allowed usable threads and processes multiple at once
            </summary>
            <returns>a list of objects containing the data that was extracted from the provided serialized string</returns>
            <exception cref="T:System.ArgumentNullException">thrown when 'assembly' or 'typeName' are null when working with a classfield object</exception>
            <exception cref="T:SnowLibrary.Serialization.TypeNotFoundException">thrown when no type was found for the classfield object</exception>
            <exception cref="T:SnowLibrary.FailedToCastTypeException">thrown when when the serializer could not cast the string value to the given field type</exception>
            <exception cref="T:SnowLibrary.Serialization.DeserializationFailedException">thrown when any error is thrown. holds this thrown error as its inner exception</exception>
        </member>
        <member name="M:SnowLibrary.Serialization.SnowSerializer.DeserializeList``1(System.String,System.Action{SnowLibrary.Serialization.SnowSerializerProgressReporter},System.Int32,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Int32)">
            <summary>
            Deserialize a string from the Snow-Format into a list of C# class objects. 
            when 'ignoreNotFoundFields' is true it will not throw an exception when it tries to deserialize a field which does not exist in the given class. the data that was linked to the field will be ignored aswell.
            if <paramref name="potatoCPU"/> is set to true it will process only 1 object at a time no matter the total objects to be handled. 
            else it will determain the best distribution among the  allowed usable threads and processes multiple at once
            </summary>
            <returns>a list of objects containing the data that was extracted from the provided serialized string</returns>
            <exception cref="T:System.ArgumentNullException">thrown when 'assembly' or 'typeName' are null when working with a classfield object</exception>
            <exception cref="T:SnowLibrary.Serialization.TypeNotFoundException">thrown when no type was found for the classfield object</exception>
            <exception cref="T:SnowLibrary.FailedToCastTypeException">thrown when when the serializer could not cast the string value to the given field type</exception>
            <exception cref="T:SnowLibrary.Serialization.DeserializationFailedException">thrown when any error is thrown. holds this thrown error as its inner exception</exception>
        </member>
        <member name="M:SnowLibrary.Serialization.SnowSerializer.DeserializeArray``1(System.String,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Int32)">
            <summary>
            Deserialize a string from the Snow-Format into an array of C# class objects.
            when 'ignoreNotFoundFields' is true it will not throw an exception when it tries to deserialize a field which does not exist in the given class. the data that was linked to the field will be ignored aswell.
            if <paramref name="potatoCPU"/> is set to true it will process only 1 object at a time no matter the total objects to be handled. 
            else it will determain the best distribution among the  allowed usable threads and processes multiple at once
            </summary>
            /// <returns>an array of objects containing the data that was extracted from the provided serialized string</returns>
            <exception cref="T:System.ArgumentNullException">thrown when 'assembly' or 'typeName' are null when working with a classfield object</exception>
            <exception cref="T:SnowLibrary.Serialization.TypeNotFoundException">thrown when no type was found for the classfield object</exception>
            <exception cref="T:SnowLibrary.FailedToCastTypeException">thrown when when the serializer could not cast the string value to the given field type</exception>
            <exception cref="T:SnowLibrary.Serialization.DeserializationFailedException">thrown when any error is thrown. holds this thrown error as its inner exception</exception>
        </member>
        <member name="M:SnowLibrary.Serialization.SnowSerializer.DeserializeArray``1(System.String,System.Action{SnowLibrary.Serialization.SnowSerializerProgressReporter},System.Int32,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Int32)">
            <summary>
            Deserialize a string from the Snow-Format into an array of C# class objects.
            when 'ignoreNotFoundFields' is true it will not throw an exception when it tries to deserialize a field which does not exist in the given class. the data that was linked to the field will be ignored aswell.
            reports its progress to the given function every time the given amount of iteration. 
            if <paramref name="potatoCPU"/> is set to true it will process only 1 object at a time no matter the total objects to be handled. 
            else it will determain the best distribution among the  allowed usable threads and processes multiple at once
            </summary>
            /// <returns>an array of objects containing the data that was extracted from the provided serialized string</returns>
            <exception cref="T:System.ArgumentNullException">thrown when 'assembly' or 'typeName' are null when working with a classfield object</exception>
            <exception cref="T:SnowLibrary.Serialization.TypeNotFoundException">thrown when no type was found for the classfield object</exception>
            <exception cref="T:SnowLibrary.FailedToCastTypeException">thrown when when the serializer could not cast the string value to the given field type</exception>
            <exception cref="T:SnowLibrary.Serialization.DeserializationFailedException">thrown when any error is thrown. holds this thrown error as its inner exception</exception>
        </member>
        <member name="M:SnowLibrary.Serialization.SnowSerializer.SerializeAsync``1(``0,System.Boolean,System.Boolean)">
            <summary>
            Asynchronously serializes an object to the Snow-Format. returns a string containing all datafields. Check the README.md provided for supported values. skips and any value with the "ExcludeFromSerialization" attribute
            </summary>
            <returns>a string format containing all data from the given object</returns>
            <exception cref="T:SnowLibrary.Serialization.TypeNotFoundException">thrown when no type corrosponding with a class field is found</exception>
            <exception cref="T:System.Exception">thrown if creation of classfield instance has failed</exception>
            <exception cref="T:SnowLibrary.Serialization.SerializationFailedException">thrown when any error is thrown. holds this thrown error as its inner exception</exception>
        </member>
        <member name="M:SnowLibrary.Serialization.SnowSerializer.SerializeListAsync``1(System.Collections.Generic.List{``0},System.Boolean,System.Boolean,System.Boolean,System.Int32)">
            <summary>
            Asynchronously Serializes a list of objects to the Snow-format.returns a string containing all objects with their datafields. can only nest 2 classes from the base class
            if the amount of items to handle is more than 5000 it uses 4 threads and processes 4 items at once
            if <paramref name="potatoCPU"/> is set to true it will process only 1 object at a time no matter the total objects to be handled. 
            else it will determain the best distribution among the  allowed usable threads and processes multiple at once
            </summary>
            <returns>string containing the data of every object instance in the provided list</returns>
            <exception cref="T:SnowLibrary.Serialization.TypeNotFoundException">thrown when no type corrosponding with a class field is found</exception>
            <exception cref="T:System.Exception">thrown if creation of classfield instance has failed</exception>
            <exception cref="T:SnowLibrary.Serialization.SerializationFailedException">thrown when any error is thrown. holds this thrown error as its inner exception</exception>
        </member>
        <member name="M:SnowLibrary.Serialization.SnowSerializer.SerializeArrayAsync``1(``0[],System.Boolean,System.Boolean,System.Boolean,System.Int32)">
            <summary>
            Asynchronously Serializes a array of objects to the Snow-format.returns a string containing all objects with their base C# datatypes
            if <paramref name="potatoCPU"/> is set to true it will process only 1 object at a time no matter the total objects to be handled. 
            if its set to false and the given amount of objects is more than 5000 it will process 4 at a time
            </summary>
            <returns>string containing the data of every object instance in the provided array</returns>
            <exception cref="T:SnowLibrary.Serialization.TypeNotFoundException">thrown when no type corrosponding with a class field is found</exception>
            <exception cref="T:System.Exception">thrown if creation of classfield instance has failed</exception>
            <exception cref="T:SnowLibrary.Serialization.SerializationFailedException">thrown when any error is thrown. holds this thrown error as its inner exception</exception>
        </member>
        <member name="M:SnowLibrary.Serialization.SnowSerializer.SerializeListAsync``1(System.Collections.Generic.List{``0},System.Action{SnowLibrary.Serialization.SnowSerializerProgressReporter},System.Int32,System.Boolean,System.Boolean,System.Boolean,System.Int32)">
            <summary>
            Asynchronously Serializes an object to the Snow=Format.
            reports its progress to the given function every given amount of iteration
            if <paramref name="potatoCPU"/> is set to true it will process only 1 object at a time no matter the total objects to be handled. 
            else it will determain the best distribution among the  allowed usable threads and processes multiple at once
            </summary>
            <returns>string containing the data of every object instance in the provided list</returns>
            <exception cref="T:SnowLibrary.Serialization.TypeNotFoundException">thrown when no type corrosponding with a class field is found</exception>
            <exception cref="T:System.Exception">thrown if creation of classfield instance has failed</exception>
            <exception cref="T:SnowLibrary.Serialization.SerializationFailedException">thrown when any error is thrown. holds this thrown error as its inner exception</exception>
        </member>
        <member name="M:SnowLibrary.Serialization.SnowSerializer.SerializeAsync``1(``0[],System.Action{SnowLibrary.Serialization.SnowSerializerProgressReporter},System.Int32,System.Boolean,System.Boolean,System.Boolean,System.Int32)">
            <summary>
            Asynchronously Serializes an object array to the Snow=Format.
            reports its progress to the given function every given amount of iteration
            if <paramref name="potatoCPU"/> is set to true it will process only 1 object at a time no matter the total objects to be handled. 
            else it will determain the best distribution among the  allowed usable threads and processes multiple at once
            </summary>
            <returns>string containing the data of every object instance in the provided list</returns>
            <exception cref="T:SnowLibrary.Serialization.TypeNotFoundException">thrown when no type corrosponding with a class field is found</exception>
            <exception cref="T:System.Exception">thrown if creation of classfield instance has failed</exception>
            <exception cref="T:SnowLibrary.Serialization.SerializationFailedException">thrown when any error is thrown. holds this thrown error as its inner exception</exception>
        </member>
        <member name="M:SnowLibrary.Serialization.SnowSerializer.DeserializeAsync``1(System.String,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Asynchronously Deserializes a string from the Snow-Format into a C# class object. 
            when 'ignoreNotFoundFields' is true it will not throw an exception when it tries to deserialize a field which does not exist in the given class. the data that was linked to the field will be ignored aswell.
            </summary>
            <returns>the deserialized object with values given from the serialized string</returns>
            <exception cref="T:System.ArgumentNullException">thrown when 'assembly' or 'typeName' are null when working with a classfield object</exception>
            <exception cref="T:SnowLibrary.Serialization.TypeNotFoundException">thrown when no type was found for the classfield object</exception>
            <exception cref="T:SnowLibrary.FailedToCastTypeException">thrown when when the serializer could not cast the string value to the given field type</exception>
            <exception cref="T:SnowLibrary.Serialization.DeserializationFailedException">thrown when any error is thrown. holds this thrown error as its inner exception</exception>
        </member>
        <member name="M:SnowLibrary.Serialization.SnowSerializer.DeserializeListAsync``1(System.String,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Int32)">
            <summary>
            Asynchronously Deserializes a string from the Snow-Format into a list of C# class objects. 
            when 'ignoreNotFoundFields' is true it will not throw an exception when it tries to deserialize a field which does not exist in the given class. the data that was linked to the field will be ignored aswell.
            if <paramref name="potatoCPU"/> is set to true it will always use 1 thread and thus process one item at a time. else it will determain the best distribution among the  allowed usable threads and processes multiple at once
            </summary>
            <returns>a list of objects containing the data that was extracted from the provided serialized string</returns>
            <exception cref="T:System.ArgumentNullException">thrown when 'assembly' or 'typeName' are null when working with a classfield object</exception>
            <exception cref="T:SnowLibrary.Serialization.TypeNotFoundException">thrown when no type was found for the classfield object</exception>
            <exception cref="T:SnowLibrary.FailedToCastTypeException">thrown when when the serializer could not cast the string value to the given field type</exception>
            <exception cref="T:SnowLibrary.Serialization.DeserializationFailedException">thrown when any error is thrown. holds this thrown error as its inner exception</exception>
        </member>
        <member name="M:SnowLibrary.Serialization.SnowSerializer.DeserializeListAsync``1(System.String,System.Action{SnowLibrary.Serialization.SnowSerializerProgressReporter},System.Int32,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Int32)">
            <summary>
            Asynchronously Deserializes a string from the Snow-Format into a list of C# class objects. 
            when 'ignoreNotFoundFields' is true it will not throw an exception when it tries to deserialize a field which does not exist in the given class. the data that was linked to the field will be ignored aswell.
            if <paramref name="potatoCPU"/> is set to true it will process only 1 object at a time no matter the total objects to be handled. 
            if its set to false, it will determain the best distribution among the  allowed usable threads and processes multiple at once
            </summary>
            <returns>a list of objects containing the data that was extracted from the provided serialized string</returns>
            <exception cref="T:System.ArgumentNullException">thrown when 'assembly' or 'typeName' are null when working with a classfield object</exception>
            <exception cref="T:SnowLibrary.Serialization.TypeNotFoundException">thrown when no type was found for the classfield object</exception>
            <exception cref="T:SnowLibrary.FailedToCastTypeException">thrown when when the serializer could not cast the string value to the given field type</exception>
            <exception cref="T:SnowLibrary.Serialization.DeserializationFailedException">thrown when any error is thrown. holds this thrown error as its inner exception</exception>
        </member>
        <member name="M:SnowLibrary.Serialization.SnowSerializer.DeserializeArrayasync``1(System.String,System.Action{SnowLibrary.Serialization.SnowSerializerProgressReporter},System.Int32,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Int32)">
            <summary>
            Asynchronously Deserializes a string from the Snow=Format into an array of C# class objects.
            when 'ignoreNotFoundFields' is true it will not throw an exception when it tries to deserialize a field which does not exist in the given class. the data that was linked to the field will be ignored aswell.
            reports its progress to the given function every time the given amount of iteration. 
            if <paramref name="potatoCPU"/> is set to true it will process only 1 object at a time no matter the total objects to be handled. 
            else it will determain the best distribution among the  allowed usable threads and processes multiple at once
            </summary>
            /// <returns>an array of objects containing the data that was extracted from the provided serialized string</returns>
            <exception cref="T:System.ArgumentNullException">thrown when 'assembly' or 'typeName' are null when working with a classfield object</exception>
            <exception cref="T:SnowLibrary.Serialization.TypeNotFoundException">thrown when no type was found for the classfield object</exception>
            <exception cref="T:SnowLibrary.FailedToCastTypeException">thrown when when the serializer could not cast the string value to the given field type</exception>
            <exception cref="T:SnowLibrary.Serialization.DeserializationFailedException">thrown when any error is thrown. holds this thrown error as its inner exception</exception>
        </member>
        <member name="T:SnowLibrary.Serialization.InvalidArgumentException">
            <summary>
            Gets thrown when an argument is invalid
            </summary>
        </member>
        <member name="T:SnowLibrary.Serialization.TypeNotFoundException">
            <summary>
            Gets thrown when a type is not found when using the serializer
            </summary>
        </member>
        <member name="T:SnowLibrary.Serialization.FieldNotSupportedException">
            <summary>
            Gets thrown when a field is not supported by the serializer
            </summary>
        </member>
        <member name="T:SnowLibrary.Serialization.FieldNotFoundException">
            <summary>
            Gets thrown when a field is not found within the current handling class, but is present in the serialized data
            </summary>
        </member>
        <member name="T:SnowLibrary.Serialization.SerializationFailedException">
            <summary>
            Gets thrown when anything fails when serializing
            </summary>
        </member>
        <member name="T:SnowLibrary.Serialization.DeserializationFailedException">
            <summary>
            Gets thrown when anything fails when deserializing
            </summary>
        </member>
        <member name="T:SnowLibrary.Serialization.SnowSerializerProgressReporter">
            <summary>
            Used to report the progress of serializing or deserializing
            </summary>
        </member>
        <member name="P:SnowLibrary.Serialization.SnowSerializerProgressReporter.Progress">
            <summary>
            the percentage of completed entries
            </summary>
        </member>
        <member name="P:SnowLibrary.Serialization.SnowSerializerProgressReporter.Message">
            <summary>
            a descriptive message 
            </summary>
        </member>
        <member name="M:SnowLibrary.Serialization.SnowSerializerProgressReporter.op_Implicit(SnowLibrary.Serialization.SnowSerializerProgressReporter)~System.String">
            <summary>
            Gets the message of progress reporter
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:SnowLibrary.Serialization.SnowSerializerProgressReporter.op_Implicit(SnowLibrary.Serialization.SnowSerializerProgressReporter)~System.Double">
            <summary>
            get the persentage value of the progress reporter
            </summary>
            <param name="e"></param>
        </member>
        <member name="T:SnowLibrary.SnowUtils">
            <summary>
            Suggestions for this class are welcome. please report them the the Author, <b>TheSnowOwl</b>
            </summary>
        </member>
        <member name="M:SnowLibrary.SnowUtils.Repeat(System.Action,System.Int32)">
            <summary>
            Repeats the given action the given amount of times.
            </summary>
            <param name="action"></param>
            <param name="times"></param>
        </member>
        <member name="M:SnowLibrary.SnowUtils.Repeat(System.Action{System.UInt64},System.UInt64)">
            <summary>
            Repeats the given action the given amount of times. gives the current iteration number as argument for the action
            </summary>
            <param name="action"></param>
            <param name="times"></param>
        </member>
        <member name="M:SnowLibrary.SnowUtils.Repeat(System.Action{System.Int32},System.Int32)">
            <summary>
            Repeats the given action the given amount of times. gives the current iteration number as argument for the action
            </summary>
            <param name="action"></param>
            <param name="times"></param>
        </member>
        <member name="M:SnowLibrary.SnowUtils.Repeat(System.Action,System.Func{System.Boolean},System.Boolean)">
            <summary>
            Repeats the given action until the condition is met. or if 'UntilConditionIsTrue' is set to true, it repeats the action while the condition is met
            </summary>
        </member>
        <member name="M:SnowLibrary.SnowUtils.RepeatAsync(System.Action,System.Int32)">
            <summary>
            Repeats the given action the given amount of times.
            </summary>
            <param name="action"></param>
            <param name="times"></param>
        </member>
        <member name="M:SnowLibrary.SnowUtils.RepeatAsync(System.Action,System.Func{System.Boolean},System.Boolean)">
            <summary>
            Repeats the given action until the condition is met. or if 'UntilConditionIsTrue' is set to true, it repeats the action while the condition is met
            </summary>
        </member>
        <member name="M:SnowLibrary.SnowUtils.ConsecutiveNumbers(System.Int32)">
            <summary>
            creates a list of consecutive numbers
            </summary>
            <param name="count"></param>
            <returns>a new list that counts from 0 to the given count - 1</returns>
        </member>
        <member name="T:SnowLibrary.SnowUtilsExtentions">
            <summary>
            Suggestions for this class are welcome. please report them the the Author, <b>TheSnowOwl</b>
            </summary>
        </member>
        <member name="M:SnowLibrary.SnowUtilsExtentions.Add``2(System.Collections.Generic.Dictionary{``0,``1},System.Collections.Generic.KeyValuePair{``0,``1})">
            <summary>
            Adds the given Pair to the Dictionary
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="dict"></param>
            <param name="pair"></param>
        </member>
        <member name="M:SnowLibrary.SnowUtilsExtentions.GetRelativeTime(System.DateTime,System.DateTime)">
            <summary>
            Calculates the relative time between the given times
            </summary>
            <param name="time"></param>
            <param name="target"></param>
            <returns>Timespan containing the relative time between the two and whether this time is in the past or not</returns>
        </member>
        <member name="M:SnowLibrary.SnowUtilsExtentions.Split``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Splits the given IEnumerable into the given amount of parts. does not keep the order of the enumerable. 
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="parts"></param>
            <returns>a list of all parts</returns>
        </member>
        <member name="M:SnowLibrary.SnowUtilsExtentions.Partition``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            determains the most efficient way to create smaller groups of the given IEnumberable and handles upon that conclution but never goes above the max alowed partitions. if put back together into one list it retains the same order (should you handle the items from the first split list to the last)
            </summary>
            <typeparam name="T"></typeparam>
            <returns>an array of lists that has elements of the IEnumberable operated on split between them</returns>
        </member>
        <member name="M:SnowLibrary.SnowUtilsExtentions.Count``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Counts the number of items present in the enumerable
            </summary>
            <typeparam name="T"></typeparam>
            <param name="enumerable"></param>
            <returns>The number of items in the enumerable</returns>
        </member>
        <member name="M:SnowLibrary.SnowUtilsExtentions.Count(System.Collections.IEnumerable)">
            <summary>
            Counts the number of items present in the enumerable
            </summary>
            <typeparam name="T"></typeparam>
            <param name="enumerable"></param>
             <returns>The number of items in the enumerable</returns>
        </member>
        <member name="M:SnowLibrary.SnowUtilsExtentions.NextAvalible(System.Collections.Generic.List{System.Int32})">
            <summary>
            finds the first unused int32 from a list
            </summary>
            <param name="list"></param>
            <returns>the next avalible int32 from a list of int32</returns>
        </member>
        <member name="M:SnowLibrary.SnowUtilsExtentions.NextAvalible``1(System.Collections.Generic.Dictionary{System.Int32,``0})">
            <summary>
            finds the first unused integer from a Dictionary which has a Key value of type Int32
            </summary>
            <returns>the next avalible interger from the Dictionary of Keys of type int32</returns>
        </member>
        <member name="M:SnowLibrary.SnowUtilsExtentions.Foreach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            executes the given action on every entry in the Enumerable
            </summary>
            <typeparam name="T"></typeparam>
            <param name="action"></param>
        </member>
        <member name="M:SnowLibrary.SnowUtilsExtentions.Repeat``1(``0,System.Action{``0},System.Int32)">
            <summary>
            Repeats the given action the given amount of times.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="source"></param>
            <param name="action"></param>
            <param name="times"></param>
        </member>
        <member name="M:SnowLibrary.SnowUtilsExtentions.Repeat``1(``0,System.Action{``0},System.Func{System.Boolean},System.Boolean)">
            <summary>
            Repeats the given action until the condition is met. or if 'UntilConditionIsTrue' is set to true, it repeats the action while the condition is met
            </summary>
            <typeparam name="T"></typeparam>
            <param name="source"></param>
            <param name="action"></param>
        </member>
        <member name="M:SnowLibrary.SnowUtilsExtentions.Foreach``1(``0[],System.Action{``0})">
            <summary>
            executes the given action on every entry in the array
            </summary>
            <typeparam name="T"></typeparam>
            <param name="array"></param>
            <param name="action"></param>
        </member>
        <member name="M:SnowLibrary.SnowUtilsExtentions.Foreach``1(``0[],System.Action{``0,System.Int32})">
            <summary>
            executes the given action on every entry in the array. passes the iteration int as the second argument.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="array"></param>
            <param name="action"></param>
        </member>
        <member name="M:SnowLibrary.SnowUtilsExtentions.ForeachAsync``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            executes the given action on every entry in the Enumerable
            </summary>
            <typeparam name="T"></typeparam>
            <param name="action"></param>
            <returns>the list where the given action is preformed on all entries</returns>
        </member>
        <member name="M:SnowLibrary.SnowUtilsExtentions.RepeatAsync``1(``0,System.Action{``0},System.Int32)">
            <summary>
            Repeats the given action the given amount of times.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="source"></param>
            <param name="action"></param>
            <param name="times"></param>
        </member>
        <member name="M:SnowLibrary.SnowUtilsExtentions.RepeatAsync``1(``0,System.Action{``0},System.Func{System.Boolean},System.Boolean)">
            <summary>
            Repeats the given action until the stop condition is met.
            </summary>
        </member>
        <member name="M:SnowLibrary.SnowUtilsExtentions.ForeachAsync``1(``0[],System.Action{``0})">
            <summary>
            executes the given action on every entry in the array
            </summary>
            <typeparam name="T"></typeparam>
            <param name="array"></param>
            <param name="action"></param>
            <returns>the array where the action has executed on all entries</returns>
        </member>
        <member name="M:SnowLibrary.SnowUtilsExtentions.Foreach``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0})">
            <summary>
            executes the given action on every entry in the Enumerable
            </summary>
            <typeparam name="T"></typeparam>
            <param name="action"></param>
            <returns>the list where the given action is preformed on all entries</returns>
        </member>
        <member name="M:SnowLibrary.SnowUtilsExtentions.Foreach``1(``0[],System.Func{``0,``0})">
            <summary>
            executes the given action on every entry in the array
            </summary>
            <typeparam name="T"></typeparam>
            <param name="array"></param>
            <param name="action"></param>
            <returns>the array where the action has executed on all entries</returns>
        </member>
        <member name="M:SnowLibrary.SnowUtilsExtentions.For``1(``0[],System.Func{``0,``0})">
            <summary>
            executes an action on every index of the array. index can be null, the default of the type will be used for this iteration then
            </summary>
            <typeparam name="T"></typeparam>
            <param name="array"></param>
            <param name="action"></param>
            <returns>the array where the action has executed for all indexes</returns>
        </member>
        <member name="M:SnowLibrary.SnowUtilsExtentions.ForeachAsync``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0})">
            <summary>
            executes the given action on every entry in the Enumerable
            </summary>
            <returns>the list where the given action is preformed on all entries</returns>
        </member>
        <member name="M:SnowLibrary.SnowUtilsExtentions.ForeachAsync``1(``0[],System.Func{``0,``0})">
            <summary>
            executes the given action on every entry in the array
            </summary>
            <typeparam name="T"></typeparam>
            <param name="array"></param>
            <param name="action"></param>
            <returns>the array where the action has executed on all entries</returns>
        </member>
        <member name="M:SnowLibrary.SnowUtilsExtentions.ForAsync``1(``0[],System.Func{``0,``0})">
            <summary>
            executes an action on every index of the array. index can be null, the default of the type will be used for this iteration then
            </summary>
            <typeparam name="T"></typeparam>
            <param name="array"></param>
            <param name="action"></param>
            <returns>the array where the action has executed for all indexes</returns>
        </member>
        <member name="T:SnowLibrary.StringWorker">
            <summary>
            Provides methods to manipulate strings 
            </summary>
        </member>
        <member name="M:SnowLibrary.StringWorker.ReverseOrder(System.String)">
            <summary>
            reverses the given string
            </summary>
            <param name="input"></param>
            <returns>a new string with its character order exactly reversed</returns>
        </member>
        <member name="M:SnowLibrary.StringWorker.FirstCapital(System.String)">
            <summary>
            makes the first letter capital while making the rest lowercase
            </summary>
            <param name="source">string to be acted on</param>
            <returns>the manipulated string where all but the first letter are lower case</returns>
        </member>
        <member name="M:SnowLibrary.StringWorker.FirstCapitalOnAllWords(System.String)">
            <summary>
            Makes all first letters of sections seperated by a space a capital letter
            </summary>
            <param name="source"></param>
            <returns>the manipulated string where every word has its first letter turned into a captial letter</returns>
        </member>
        <member name="M:SnowLibrary.StringWorker.Base64Encode(System.String)">
            <summary>
            converts the given string to a base64 format
            </summary>
            <param name="plainText"></param>
            <returns>the base64 result from the given string</returns>
        </member>
        <member name="M:SnowLibrary.StringWorker.Base64Decode(System.String)">
            <summary>
            converts the given base64 format into UTF8 characters
            </summary>
            <param name="base64EncodedData"></param>
            <returns>the UTF8 string result from the given base64 format input</returns>
        </member>
        <member name="M:SnowLibrary.StringWorker.StringAnimation(System.String,System.Int32)">
            <summary>
            allows easy animation of a string to be shown to the user. combine with <b>Foreach()</b>, <b>ForeachAsync()</b>, or any other foreach loop to attchieve the desired result
            </summary>
            <param name="content"></param>
            <param name="delay"></param>
            <returns>yield returns a string with one extra character than the last until the given <paramref name="content"/> is returned in its fullest</returns>
        </member>
        <member name="M:SnowLibrary.StringWorker.StringAnimationChar(System.String,System.Int32)">
            <summary>
            allows easy animation of a string to be shown to the user. combine with <b>Foreach()</b>, <b>ForeachAsync()</b>, or any other foreach loop to attchieve the desired result
            </summary>
            <param name="content"></param>
            <param name="delay"></param>
            <returns>yield returns a char taken from the given <paramref name="content"/> until the last char has been returned</returns>
        </member>
        <member name="T:SnowLibrary.TypeWorker">
            <summary>
            Provides methods for finding a type or method within accessable assembiles, and easy casting to and from default data types
            </summary>
        </member>
        <member name="M:SnowLibrary.TypeWorker.ConvertTo(System.Object,System.Type)">
            <summary>
            the same as Convert.ChangeType(object frrom, object To) except this returns a dynamic instead of an object
            </summary>
            <param name="from"></param>
            <param name="to"></param>
            <returns>a dynamic object converted to the given type. or null if converting failed</returns>
        </member>
        <member name="M:SnowLibrary.TypeWorker.FindType(System.String,System.Reflection.Assembly)">
            <summary>
            Searches for the Type matching to the given name. can pass the assembly as filter for the search
            </summary>
            <returns>The type matching the given name if it is found within the current accessable assemblies. if no matching type is found it returns null</returns>
        </member>
        <member name="M:SnowLibrary.TypeWorker.FindType(System.String,System.String)">
            <summary>
            Searches for the Type matching to the given name. can pass the assembly as filter for the search. be sure to just give the name of the assembly
            </summary>
            <returns>The type matching the given name if it is found within the given Assembly. if no matching type is found it returns null</returns>
        </member>
        <member name="M:SnowLibrary.TypeWorker.FindMethod(System.Type,System.String)">
            <summary>
            Searches for a method within the given type that has the given name.
            </summary>
            <param name="containing"></param>
            <param name="name"></param>
            <returns>returns the found method info if a method with the given name is found, otherwise returns null</returns>
        </member>
        <member name="M:SnowLibrary.TypeWorker.CastPrimitive(System.Object,System.Type,System.Reflection.Assembly,System.String)">
            <summary>
            Casts the given file to the given destination type. should this fail it throws an exception
            </summary>
            <param name="from"></param>
            <param name="to"></param>
            <param name="targetAssembly"></param>
            <param name="targetTypeName"></param>
            <returns>the converted value</returns>
            <exception cref="T:SnowLibrary.Serialization.TypeNotFoundException"></exception>
            <exception cref="T:SnowLibrary.FailedToCastTypeException"></exception>
            <exception cref="T:SnowLibrary.CastTypeNotSupportedException"></exception>
        </member>
        <member name="M:SnowLibrary.TypeWorker.CastPrimitive``1(System.Object,``0,System.Reflection.Assembly,System.String)">
            <summary>
            Casts the given file to the given destination type. should this fail it throws an exception
            </summary>
            <typeparam name="T"></typeparam>
            <param name="from"></param>
            <param name="to"></param>
            <param name="targetAssembly"></param>
            <param name="targetTypeName"></param>
            <returns>the converted value</returns>
            <exception cref="T:SnowLibrary.Serialization.TypeNotFoundException"></exception>
            <exception cref="T:SnowLibrary.FailedToCastTypeException"></exception>
            <exception cref="T:SnowLibrary.CastTypeNotSupportedException"></exception>
        </member>
        <member name="M:SnowLibrary.TypeWorker.CastPrimitive``1(System.Object)">
            <summary>
            Casts the given file to the given destination type. should this fail it throws an exception
            </summary>
            <typeparam name="T"></typeparam>
            <param name="from"></param>
            <returns>the converted value</returns>
            <exception cref="T:SnowLibrary.Serialization.TypeNotFoundException"></exception>
            <exception cref="T:SnowLibrary.FailedToCastTypeException"></exception>
            <exception cref="T:SnowLibrary.CastTypeNotSupportedException"></exception>
        </member>
        <member name="T:SnowLibrary.FailedToCastTypeException">
            <summary>
            Gets thrown when casting fails
            </summary>
        </member>
        <member name="T:SnowLibrary.CastTypeNotSupportedException">
            <summary>
            Gets thrown when destination type is not supported by the <b>CastPrimitive</b> method
            </summary>
        </member>
        <member name="T:SnowLibrary.MethodNotFoundException">
            <summary>
            Gets thrown when a linked method for events when serializing is not found
            </summary>
        </member>
        <member name="T:SnowLibrary.Vectors.Vector2">
            <summary>
            An object that represents a point in 2D worldspace
            </summary>
        </member>
        <member name="F:SnowLibrary.Vectors.Vector2.x">
            <summary>
            Vector2 cordinate
            </summary>
        </member>
        <member name="F:SnowLibrary.Vectors.Vector2.y">
            <summary>
            Vector2 cordinate
            </summary>
        </member>
        <member name="M:SnowLibrary.Vectors.Vector2.#ctor(System.Single,System.Single)">
            <summary>
            poppulated constructor
            </summary>
        </member>
        <member name="M:SnowLibrary.Vectors.Vector2.#ctor">
            <summary>
            empty constructor
            </summary>
        </member>
        <member name="M:SnowLibrary.Vectors.Vector2.ToString">
            <summary>
            gets a string representation of this Vector2 object
            </summary>
            <returns></returns>
        </member>
        <member name="M:SnowLibrary.Vectors.Vector2.Random(System.Int32,System.Int32)">
            <summary>
            generates a vector2 with random values
            </summary>
            <returns>new vector2 where the values xy are randomized</returns>
        </member>
        <member name="M:SnowLibrary.Vectors.Vector2.Distance(SnowLibrary.Vectors.Vector2,SnowLibrary.Vectors.Vector2)">
            <summary>
            gets the distance between 2 vector2 points
            </summary>
            <returns>a float with the distance between the 2 points in a straight line</returns>
        </member>
        <member name="M:SnowLibrary.Vectors.Vector2.op_Addition(SnowLibrary.Vectors.Vector2,SnowLibrary.Vectors.Vector2)">
            <summary>
            Adds 2 Vector2 together
            </summary>
            <returns>a new vector2 where the 2 values are added together</returns>
        </member>
        <member name="M:SnowLibrary.Vectors.Vector2.op_Addition(SnowLibrary.Vectors.Vector2,System.Single)">
            <summary>
            adds a float value to a vector2
            </summary>
            <returns>a new vector2 where the float has been added to the original values</returns>
        </member>
        <member name="M:SnowLibrary.Vectors.Vector2.op_Subtraction(SnowLibrary.Vectors.Vector2,SnowLibrary.Vectors.Vector2)">
            <summary>
            subtracts 2 Vector2 from eachother
            </summary>
            <returns>a new vector2 where the 2 values are subtracted</returns>
        </member>
        <member name="M:SnowLibrary.Vectors.Vector2.op_Subtraction(SnowLibrary.Vectors.Vector2,System.Single)">
            <summary>
            subtracts a float value from a vector2
            </summary>
            <returns>a new vector2 where the float has been subtracted from the original values</returns>
        </member>
        <member name="M:SnowLibrary.Vectors.Vector2.op_Division(SnowLibrary.Vectors.Vector2,SnowLibrary.Vectors.Vector2)">
            <summary>
            devides the values of 2 vector2
            </summary>
            <returns>a new vector2 where the values have been diveded with eachother</returns>
        </member>
        <member name="M:SnowLibrary.Vectors.Vector2.op_Division(SnowLibrary.Vectors.Vector2,System.Single)">
            <summary>
            devides the values of a vector2 with a float
            </summary>
            <returns>a new vector2 where the values are devided by the float</returns>
        </member>
        <member name="M:SnowLibrary.Vectors.Vector2.op_Multiply(SnowLibrary.Vectors.Vector2,SnowLibrary.Vectors.Vector2)">
            <summary>
            multiplies the values together
            </summary> 
            <returns>a new vector2 where the values are multiplied by eachother</returns>
        </member>
        <member name="M:SnowLibrary.Vectors.Vector2.op_Multiply(SnowLibrary.Vectors.Vector2,System.Single)">
            <summary>
            multiplies the values by a float
            </summary>
            <returns>a new vector2 where the values are multiplied by the float</returns>
        </member>
        <member name="M:SnowLibrary.Vectors.Vector2.op_Modulus(SnowLibrary.Vectors.Vector2,SnowLibrary.Vectors.Vector2)">
            <summary>
            makes a new vector3 with the remainders of a devision
            </summary>
            <returns>a new vector2 with the remainders of a devision as its values</returns>
        </member>
        <member name="M:SnowLibrary.Vectors.Vector2.op_Modulus(SnowLibrary.Vectors.Vector2,System.Single)">
             <summary></summary>
            <returns>a new vector2 where the values are the remainers of a division</returns>
        </member>
        <member name="M:SnowLibrary.Vectors.Vector2.op_GreaterThan(SnowLibrary.Vectors.Vector2,SnowLibrary.Vectors.Vector2)">
            <summary></summary>
            <returns>true if left value is greater than the right value</returns>
        </member>
        <member name="M:SnowLibrary.Vectors.Vector2.op_LessThan(SnowLibrary.Vectors.Vector2,SnowLibrary.Vectors.Vector2)">
            <summary></summary>
            <returns>true if right value is greater than the left value</returns>
        </member>
        <member name="M:SnowLibrary.Vectors.Vector2.op_GreaterThan(SnowLibrary.Vectors.Vector2,System.Single)">
            <summary></summary>
            <returns>true if left value is greater than the right value</returns>
        </member>
        <member name="M:SnowLibrary.Vectors.Vector2.op_LessThan(SnowLibrary.Vectors.Vector2,System.Single)">
            <summary></summary>
            <returns>true if right value is greater than the left value</returns>
        </member>
        <member name="M:SnowLibrary.Vectors.Vector2.op_GreaterThanOrEqual(SnowLibrary.Vectors.Vector2,SnowLibrary.Vectors.Vector2)">
            <summary></summary>
            <returns>true if left value is greater than, or equal the right value</returns>
        </member>
        <member name="M:SnowLibrary.Vectors.Vector2.op_LessThanOrEqual(SnowLibrary.Vectors.Vector2,SnowLibrary.Vectors.Vector2)">
            <summary></summary>
            <returns>true if right value is greater than, or equal the left value</returns>
        </member>
        <member name="T:SnowLibrary.Vectors.Vector3">
            <summary>
            An object that represents a position in 3D worldspace
            </summary>
        </member>
        <member name="F:SnowLibrary.Vectors.Vector3.x">
            <summary>
            Vector3 cordinate
            </summary>
        </member>
        <member name="F:SnowLibrary.Vectors.Vector3.y">
            <summary>
            Vector3 cordinate
            </summary>
        </member>
        <member name="F:SnowLibrary.Vectors.Vector3.z">
            <summary>
            Vector3 cordinate
            </summary>
        </member>
        <member name="M:SnowLibrary.Vectors.Vector3.#ctor(System.Single,System.Single,System.Single)">
            <summary>
            poppulation constructor
            </summary>
            <param name="x">x</param>
            <param name="y">y</param>
            <param name="z">z</param>
        </member>
        <member name="M:SnowLibrary.Vectors.Vector3.#ctor">
            <summary>
            empty constructor
            </summary>
        </member>
        <member name="M:SnowLibrary.Vectors.Vector3.ToString">
            <summary>
            Returns a string representation of the Vector3
            </summary>
            <returns></returns>
        </member>
        <member name="M:SnowLibrary.Vectors.Vector3.Random(System.Int32,System.Int32)">
            <summary>
            generates a vector3 with random values
            </summary>
            <returns>new vector3 where the values xyz are randomized</returns>
        </member>
        <member name="M:SnowLibrary.Vectors.Vector3.Distance(SnowLibrary.Vectors.Vector3,SnowLibrary.Vectors.Vector3)">
            <summary>
            gets the distance between 2 vector3 points
            </summary>
            <returns>a float with the distance between the 2 points in a straight line</returns>
        </member>
        <member name="M:SnowLibrary.Vectors.Vector3.op_Addition(SnowLibrary.Vectors.Vector3,SnowLibrary.Vectors.Vector3)">
            <summary>
            Adds 2 Vector3 together
            </summary>
            <returns>a new vector3 where the 2 values are added together</returns>
        </member>
        <member name="M:SnowLibrary.Vectors.Vector3.op_Addition(SnowLibrary.Vectors.Vector3,System.Single)">
            <summary>
            adds a float value to a vector3
            </summary>
            <returns>a new vector3 where the float has been added to the original values</returns>
        </member>
        <member name="M:SnowLibrary.Vectors.Vector3.op_Subtraction(SnowLibrary.Vectors.Vector3,SnowLibrary.Vectors.Vector3)">
            <summary>
            subtracts 2 Vector3 from eachother
            </summary>
            <returns>a new vector3 where the 2 values are subtracted</returns>
        </member>
        <member name="M:SnowLibrary.Vectors.Vector3.op_Subtraction(SnowLibrary.Vectors.Vector3,System.Single)">
            <summary>
            subtracts a float value from a vector3
            </summary>
            <returns>a new vector3 where the float has been subtracted from the original values</returns>
        </member>
        <member name="M:SnowLibrary.Vectors.Vector3.op_Division(SnowLibrary.Vectors.Vector3,SnowLibrary.Vectors.Vector3)">
            <summary>
            devides the values of 2 vector3
            </summary>
            <returns>a new vector3 where the values have been diveded with eachother</returns>
        </member>
        <member name="M:SnowLibrary.Vectors.Vector3.op_Division(SnowLibrary.Vectors.Vector3,System.Single)">
            <summary>
            devides the values of a vector3 with a float
            </summary>
            <returns>a new vector3 where the values are devided by the float</returns>
        </member>
        <member name="M:SnowLibrary.Vectors.Vector3.op_Multiply(SnowLibrary.Vectors.Vector3,SnowLibrary.Vectors.Vector3)">
            <summary>
            multiplies the values together
            </summary>
            <returns>a new vector3 where the values are multiplied by eachother</returns>
        </member>
        <member name="M:SnowLibrary.Vectors.Vector3.op_Multiply(SnowLibrary.Vectors.Vector3,System.Single)">
            <summary>
            multiplies the values by a float
            </summary>
            <returns>a new vector3 where the values are multiplied by the float</returns>
        </member>
        <member name="M:SnowLibrary.Vectors.Vector3.op_Modulus(SnowLibrary.Vectors.Vector3,SnowLibrary.Vectors.Vector3)">
            <summary>
            makes a new vector3 with the remainders of a devision
            </summary>
            <returns>a new vector3 where the values are the remainers of a division</returns>
        </member>
        <member name="M:SnowLibrary.Vectors.Vector3.op_Modulus(SnowLibrary.Vectors.Vector3,System.Single)">
             <summary>
             makes a new vector3 with the remainders of a devision
             </summary>
            <returns>a new vector3 where the values are the remainers of a division</returns>
        </member>
        <member name="M:SnowLibrary.Vectors.Vector3.op_GreaterThan(SnowLibrary.Vectors.Vector3,SnowLibrary.Vectors.Vector3)">
            <summary></summary>
            <returns>true if left value is greater than the right value</returns>
        </member>
        <member name="M:SnowLibrary.Vectors.Vector3.op_LessThan(SnowLibrary.Vectors.Vector3,SnowLibrary.Vectors.Vector3)">
            <summary></summary>
            <returns>true if right value is greater than the left value</returns>
        </member>
        <member name="M:SnowLibrary.Vectors.Vector3.op_GreaterThan(SnowLibrary.Vectors.Vector3,System.Single)">
            <summary></summary>
            <returns>true if left value is greater than the right value</returns>
        </member>
        <member name="M:SnowLibrary.Vectors.Vector3.op_LessThan(SnowLibrary.Vectors.Vector3,System.Single)">
            <summary></summary>
            <returns>true if right value is greater than the left value</returns>
        </member>
        <member name="M:SnowLibrary.Vectors.Vector3.op_GreaterThanOrEqual(SnowLibrary.Vectors.Vector3,SnowLibrary.Vectors.Vector3)">
            <summary></summary>
            <returns>true if left value is greater than, or equal the right value</returns>
        </member>
        <member name="M:SnowLibrary.Vectors.Vector3.op_LessThanOrEqual(SnowLibrary.Vectors.Vector3,SnowLibrary.Vectors.Vector3)">
            <summary></summary>
            <returns>true if right value is greater than, or equal the left value</returns>
        </member>
        <member name="T:SnowLibrary.WIP.RedisDatabase.Redis">
            <summary>
            connection to the Redis Database to store and retrieve data externally. 
            </summary>
        </member>
        <member name="M:SnowLibrary.WIP.RedisDatabase.Redis.#ctor(System.String,System.Int32,System.String)">
            <summary>
            tries to establish a connection to the Redis database using the given connection link, port, and password. should this fail it throws an ConnectionFailedException
            </summary>
            <param name="connection"></param>
            <param name="port"></param>
            <param name="password"></param>
        </member>
        <member name="M:SnowLibrary.WIP.RedisDatabase.Redis.#ctor(System.String,System.Int32)">
            <summary>
            tries to establish a connection to the Redis database using the given connection link, and port. should this fail it throws an ConnectionFailedException
            </summary>
            <param name="connection"></param>
            <param name="port"></param>
        </member>
        <member name="M:SnowLibrary.WIP.RedisDatabase.Redis.Finalize">
            <summary>
            deconstructor
            </summary>
        </member>
        <member name="M:SnowLibrary.WIP.RedisDatabase.Redis.Set``1(System.String,``0)">
            <summary>
            Adds the specified key to the database and links the data converted to the Snow Format using <b>SnowLibrary.Serializer.SnowSerializer</b> as its value. should the given key already exist it overrides the value
            </summary>
            <typeparam name="T"></typeparam>
            <param name="key"></param>
            <param name="data"></param>
        </member>
        <member name="M:SnowLibrary.WIP.RedisDatabase.Redis.Set``1(System.String,``0,System.TimeSpan)">
            <summary>
            Adds the specified key to the database and links the data converted to the Snow Format using <b>SnowLibrary.Serializer.SnowSerializer</b> as its value. should the given key already exist it overrides the value. the key will expire after the given date and time
            </summary>
            <typeparam name="T"></typeparam>
            <param name="key"></param>
            <param name="data"></param>
        </member>
        <member name="M:SnowLibrary.WIP.RedisDatabase.Redis.Get``1(System.String)">
            <summary>
            Gets the value of the given key, should this key not exist, it returns <b>null</b>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:SnowLibrary.WIP.RedisDatabase.Redis.GetAll``1">
            <summary>
            gets all entries of the specified type from the database, and returns them as a list
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:SnowLibrary.WIP.RedisDatabase.Redis.GetAllAsync``1">
            <summary>
            gets all entries of the specified type from the database
            </summary>
            <typeparam name="T"></typeparam>
            <returns>returns all objects of the given type in a list</returns>
        </member>
        <member name="M:SnowLibrary.WIP.RedisDatabase.Redis.Remove(System.String)">
            <summary>
            Removes the key and its value from the database
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:SnowLibrary.WIP.RedisDatabase.Redis.KeyExist(System.String)">
            <summary>
            checks if the given key exists within the database
            </summary>
            <param name="key"></param>
            <returns>true if the key was found, false if it was not</returns>
        </member>
        <member name="M:SnowLibrary.WIP.RedisDatabase.Redis.SetKeyExpire(System.String,System.TimeSpan)">
            <summary>
            sets the expire time for the given key, the time is measured as countdown
            </summary>
            <param name="key"></param>
            <param name="time"></param>
            <returns>true if the operation was successful, false if not</returns>
        </member>
        <member name="M:SnowLibrary.WIP.RedisDatabase.Redis.RemoveKeyExpire(System.String)">
            <summary>
            Removes the timeout from the given key
            </summary>
            <param name="key"></param>
            <returns>returns true if the timeout was removed, false if the key doesnt exist or the key doesnt have a timeout</returns>
        </member>
        <member name="M:SnowLibrary.WIP.RedisDatabase.Redis.Ping">
            <summary>
            used for checking if the connection is still alive, or to get the latency
            </summary>
            <returns>TimeSpan for latency to the database </returns>
        </member>
        <member name="M:SnowLibrary.WIP.RedisDatabase.Redis.GetAllKeys">
            <summary>
            gets all the keys from the database
            </summary>
            <returns>returns all the keys that are stored in the database, this ignores their values</returns>
        </member>
        <member name="M:SnowLibrary.WIP.RedisDatabase.Redis.EditKey``1(System.String,System.String)">
            <summary>
            changes the key to another, while keeping its value
            </summary>
            <typeparam name="T"></typeparam>
            <param name="key"></param>
            <param name="newKey"></param>
            <returns>true if the operation failed, false if not</returns>
        </member>
        <member name="M:SnowLibrary.WIP.RedisDatabase.Redis.Flush">
            <summary>
            WARNING: This will delete <b>EVERY</b> entry in your database
            </summary>
        </member>
        <member name="M:SnowLibrary.WIP.RedisDatabase.Redis.Dispose">
            <summary>
            Clear the connection to the database
            </summary>
        </member>
        <member name="M:SnowLibrary.WIP.RedisDatabase.Redis.Disconnect">
            <summary>
            Clears the connection to the database and disposes of this object.
            </summary>
        </member>
        <member name="T:SnowLibrary.WIP.RedisDatabase.Redis.ConnectionFailedException">
            <summary>
            gets thrown when the connection was not sucessfully established
            </summary>
        </member>
        <member name="T:SnowLibrary.WIP.RedisDatabase.RedisData">
            <summary>
            this class is used by the library to make certain things work. this is not intended for users of the library.
            </summary>
        </member>
    </members>
</doc>
