<?xml version="1.0"?>
<doc>
    <assembly>
        <name>WinterRose</name>
    </assembly>
    <members>
        <member name="T:WinterRose.ConsoleExtentions.Input">
            <summary>
            Allows for easy key input gathering from console applications
            </summary>
        </member>
        <member name="M:WinterRose.ConsoleExtentions.Input.GetKey(System.ConsoleKey,System.Boolean,System.Boolean)">
            <summary>
            gets the specified key. using intercept to determain if the pressed key should appear in the console.
            </summary>
            <param name="key"></param>
            <param name="intercept"></param>
            <param name="wait"></param>
            <returns>returns true when the key is pressed. otherwise, if wait is set to false and the key is not being pressed, it returns false</returns>
        </member>
        <member name="T:WinterRose.ConsoleExtentions.ConsoleS">
            <summary>
            Extra stuff for console applications
            </summary>
        </member>
        <member name="M:WinterRose.ConsoleExtentions.ConsoleS.WriteErrorLine``1(``0)">
            <summary>
            Writes a red text line with slight indent to the console
            </summary>
            <typeparam name="T"></typeparam>
            <param name="Message"></param>
        </member>
        <member name="M:WinterRose.ConsoleExtentions.ConsoleS.WriteError``1(``0)">
            <summary>
            Writes the red text to the console with a tab before it
            </summary>
            <typeparam name="T"></typeparam>
            <param name="Message"></param>
        </member>
        <member name="M:WinterRose.ConsoleExtentions.ConsoleS.WriteWarningLine``1(``0)">
            <summary>
            Writes a yellow text line with slight indent to the console
            </summary>
            <typeparam name="T"></typeparam>
            <param name="Message"></param>
        </member>
        <member name="M:WinterRose.ConsoleExtentions.ConsoleS.WriteWarning``1(``0)">
            <summary>
            Writes the yellow text to the console with a tab before it
            </summary>
            <typeparam name="T"></typeparam>
            <param name="Message"></param>
        </member>
        <member name="T:WinterRose.ConsoleExtentions.WindowFlasher">
            <summary>
            Allows for flashing of Console Windows
            </summary>
        </member>
        <member name="F:WinterRose.ConsoleExtentions.WindowFlasher.FLASHWINFO.cbSize">
            <summary>
            The size of the structure, in bytes
            </summary>
        </member>
        <member name="F:WinterRose.ConsoleExtentions.WindowFlasher.FLASHWINFO.hwnd">
            <summary>
            A handle to the window to be flashed. The window can be either opened or minimized.
            </summary>
        </member>
        <member name="F:WinterRose.ConsoleExtentions.WindowFlasher.FLASHWINFO.dwFlags">
            <summary>
            The flash status. This parameter can be one or more of the following values.
            </summary>
        </member>
        <member name="F:WinterRose.ConsoleExtentions.WindowFlasher.FLASHWINFO.uCount">
            <summary>
            The number of times to flash the window.
            </summary>
        </member>
        <member name="F:WinterRose.ConsoleExtentions.WindowFlasher.FLASHWINFO.dwTimeout">
            <summary>
            The rate at which the window is to be flashed, in milliseconds. If dwTimeout is zero, the function uses the default cursor blink rate.
            </summary>
        </member>
        <member name="F:WinterRose.ConsoleExtentions.WindowFlasher.FLASHW_ALL">
            <summary>
            Flash both the window caption and taskbar button. This is equivalent to setting the FLASHW_CAPTION | FLASHW_TRAY flags.
            </summary>
        </member>
        <member name="F:WinterRose.ConsoleExtentions.WindowFlasher.FLASHW_STOP">
            <summary>
            Stop flashing. The system restores the window to its original state.
            </summary>
        </member>
        <member name="M:WinterRose.ConsoleExtentions.WindowFlasher.GetFLASHWINFO(System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Create an instance of the FLASHWINFO structure
            </summary>
            <param name="flashwConstant">One of the provided FLASHW contant values</param>
            <param name="uCount">uCount to initialize the struct</param>
            <param name="dwTimeout">dwTimeout to initalize the struct</param>
            <returns>A fully instantiated FLASHWINFO struct</returns>
        </member>
        <member name="M:WinterRose.ConsoleExtentions.WindowFlasher.Flash(System.UInt32)">
            <summary>
            Flashes the console window (continues indefinitely)
            </summary>
        </member>
        <member name="M:WinterRose.ConsoleExtentions.WindowFlasher.StopFlash">
            <summary>
            Stops the flashing of the console window
            </summary>
        </member>
        <member name="T:WinterRose.Encryption.Encryptor">
            <summary>
            Provides a methods to encrypt and decrypt messages.
            </summary>
        </member>
        <member name="F:WinterRose.Encryption.Encryptor.KEYSIZE">
            <summary>
            The size of the keys when using the encrypter
            </summary>
        </member>
        <member name="M:WinterRose.Encryption.Encryptor.Encrypt(System.String,System.String,System.String,System.String)">
            <summary>
            Encrypt the given message using the cridentals stored in provided settings object
            </summary>
            <param name="message"></param>
            <param name="settings"></param>
            <returns>The encrypted message</returns>
        </member>
        <member name="M:WinterRose.Encryption.Encryptor.Encrypt(System.String,WinterRose.Encryption.EncryptorSettings)">
            <summary>
            Encrypt the given message using the cridentals stored in provided settings object
            </summary>
            <param name="message"></param>
            <param name="settings"></param>
            <returns>The encrypted message</returns>
        </member>
        <member name="M:WinterRose.Encryption.Encryptor.Decrypt(System.String,System.String,System.String,System.String)">
            <summary>
            Decrypt the given encrypted message using the cridentials stored in the provided settings object
            </summary>
            <param name="message"></param>
            <param name="settings"></param>
            <returns>The decrypted message</returns>
        </member>
        <member name="M:WinterRose.Encryption.Encryptor.Decrypt(System.String,WinterRose.Encryption.EncryptorSettings)">
            <summary>
            Decrypt the given encrypted message using the cridentials stored in the provided settings object
            </summary>
            <param name="message"></param>
            <param name="settings"></param>
            <returns>The decrypted message</returns>
        </member>
        <member name="T:WinterRose.Encryption.EncryptorSettings">
            <summary>
            Holds settings for the encrypter class to use. makes it easier to use these settings in multiple encrypters
            </summary>
        </member>
        <member name="M:WinterRose.Encryption.EncryptorSettings.#ctor(System.String,System.String,System.String)">
            <summary>
            Creates a new instance of the EncrypterSettings class
            </summary>
            <param name="password"></param>
            <param name="salt"></param>
            <param name="iv"></param>
        </member>
        <member name="T:WinterRose.Encryption.StringScrambler">
            <summary>
            Scrambles strings with special settings settings
            </summary>
        </member>
        <member name="F:WinterRose.Encryption.StringScrambler.SupportedCharacters">
            <summary>
            Represents a string literal that shows all supported characters by the scrambler
            </summary>
        </member>
        <member name="M:WinterRose.Encryption.StringScrambler.#ctor(WinterRose.Encryption.ScramblerSettings,WinterRose.Encryption.ScramblerSettings,WinterRose.Encryption.ScramblerSettings)">
            <summary>
            Creates a new instance of the Encryptor class
            </summary>
            <param name="setting1"></param>
            <param name="setting2"></param>
            <param name="setting3"></param>
        </member>
        <member name="M:WinterRose.Encryption.StringScrambler.Encrypt(System.String)">
            <summary>
            encrypts the given message.
            </summary>
            <returns>The resulting string from the encrypting</returns>
            <param name="message"></param>
        </member>
        <member name="M:WinterRose.Encryption.StringScrambler.Encrypt(WinterRose.MutableString,System.Action{WinterRose.ProgressReporter},System.Int32)">
            <summary>
            encrypts the given message.
            </summary>
            <param name="message"></param>
            <param name="progress"></param>
            <param name="reportAt"></param>
            <returns>The resulting string from the encrypting</returns>
        </member>
        <member name="M:WinterRose.Encryption.StringScrambler.Decrypt(System.String)">
            <summary>
            Decrypts the given message
            </summary>
            <param name="message"></param>
            <returns>the resulting string from the decryption</returns>
        </member>
        <member name="M:WinterRose.Encryption.StringScrambler.Decrypt(System.String,System.Action{WinterRose.ProgressReporter},System.Int32)">
            <summary>
            Decrypts the given message
            </summary>
            <param name="message"></param>
            <param name="progress"></param>
            <param name="reportAt"></param>
            <returns>the resulting string from the decryption</returns>
        </member>
        <member name="T:WinterRose.Encryption.ScramblerSettings">
            <summary>
            this struct is part of the Scrambling. It is used to store the settings for the Scrambling
            </summary>
        </member>
        <member name="M:WinterRose.Encryption.ScramblerSettings.#ctor(WinterRose.Encryption.ScrambleConfiguration,System.Int32,System.Int32)">
            <summary>
            creates a new instance of the Rotor class
            </summary>
            <param name="configuration">Selects which config is chosen for this specific rotor</param>
            <param name="offset">indicates at what position the rotor starts at</param>
            <param name="moveNext">at what rotation of this rotor should it signal the rotation of the next</param>
        </member>
        <member name="T:WinterRose.Encryption.ScrambleConfiguration">
            <summary>
            Makes for easy determaining what rotor configuration to choose from
            </summary>
        </member>
        <member name="F:WinterRose.Encryption.ScrambleConfiguration.I">
            <summary>
            Represents the first configuration
            </summary>
        </member>
        <member name="F:WinterRose.Encryption.ScrambleConfiguration.II">
            <summary>
            Represents the second configuratio
            </summary>
        </member>
        <member name="F:WinterRose.Encryption.ScrambleConfiguration.III">
            <summary>
            Represents the third configuration
            </summary>
        </member>
        <member name="F:WinterRose.Encryption.ScrambleConfiguration.IV">
            <summary>
            Represents the fourth configuratio
            </summary>
        </member>
        <member name="F:WinterRose.Encryption.ScrambleConfiguration.V">
            <summary>
            Represents the fifth configuration
            </summary>
        </member>
        <member name="T:WinterRose.FileManagement.DirectorySerializer">
            <summary>
            Provides methods to serialize or deserialize a directory
            </summary>
        </member>
        <member name="M:WinterRose.FileManagement.DirectorySerializer.SerializeDirectory(System.String)">
            <summary>
            serializes the given directory
            </summary>
            <param name="directoryToSerialize">path to the directory to be serialized</param>
            <returns>a string containing data of the serialized directory</returns>
        </member>
        <member name="M:WinterRose.FileManagement.DirectorySerializer.DeserializeDirectory(System.String,System.String)">
            <summary>
            Deserialized the given directory
            </summary>
            <param name="archiveContent"></param>
            <param name="directoryDestination"></param>
            <returns>true if the operation was succesfull, false if it wasnt</returns>
        </member>
        <member name="T:WinterRose.FileManagement.SerializedFile">
            <summary>
            represents a serialized file
            </summary>
        </member>
        <member name="M:WinterRose.FileManagement.SerializedFile.#ctor(System.String,System.String,System.String)">
            <summary>
            creates a new instance of the SerializedFile class with the given properties
            </summary>
            <param name="fileName"></param>
            <param name="fileExtention"></param>
            <param name="content"></param>
        </member>
        <member name="M:WinterRose.FileManagement.SerializedFile.#ctor">
            <summary>
            creates an empty intance of the SerializedFile class
            </summary>
        </member>
        <member name="M:WinterRose.FileManagement.SerializedFile.SerializeFile(System.String)">
            <summary>
            serializes the file at the given path
            </summary>
            <param name="path"></param>
            <returns>the serialized file</returns>
        </member>
        <member name="T:WinterRose.FileManagement.FileManager">
            <summary>
            Allows for easy file manipulation. For suggestions please relay them to <b>TheSnowOwl</b>
            </summary>
        </member>
        <member name="M:WinterRose.FileManagement.FileManager.Write(System.String,System.String,System.Boolean)">
            <summary>
            Write a given string to a text file. include the .txt in the path. Method creates new file and directory if either does not exists.
            </summary>
        </member>
        <member name="M:WinterRose.FileManagement.FileManager.WriteLine(System.String,System.String,System.Boolean)">
            <summary>
            Write a given string to a text file on a new line. include the .txt in the path. Method creates new file and directory if either does not exists.
            </summary>
            <param name="path"></param>
            <param name="content"></param>
            <param name="overrideFile"></param>
        </member>
        <member name="M:WinterRose.FileManagement.FileManager.Read(System.String)">
            <summary>
            Reads all text from the FileStream from beginning to end
            </summary>
            <returns>one conplete string of all text in the file</returns>
            <exception cref="T:System.IO.FileNotFoundException"></exception>
        </member>
        <member name="M:WinterRose.FileManagement.FileManager.TryRead(System.String)">
            <summary>
            attempts to read the given file
            </summary>
            <param name="path"></param>
            <returns>if the given file does not exist, or is already used, returns null</returns>
        </member>
        <member name="M:WinterRose.FileManagement.FileManager.ReadLine(System.String,System.Int32)">
            <summary>
            reads the specified line
            </summary>
            <param name="path"></param>
            <param name="lineNumber"></param>
            <returns>the string that exists on the specified line</returns>
            <exception cref="T:System.IO.FileNotFoundException"></exception>
            <exception cref="T:WinterRose.FileManagement.LineNumberTooGreatException"></exception>
        </member>
        <member name="M:WinterRose.FileManagement.FileManager.ReadAllLines(System.String)">
            <summary>
            reads all lines in the file
            </summary>
            <param name="path"></param>
            <returns>a string array of all lines</returns>
            <exception cref="T:System.IO.FileNotFoundException"></exception>
        </member>
        <member name="M:WinterRose.FileManagement.FileManager.WriteAsync(System.String,System.String,System.Boolean)">
            <summary>
            Write a given string to a text file. include the .txt in the path. Method creates new file and directory if either does not exists.
            </summary>
        </member>
        <member name="M:WinterRose.FileManagement.FileManager.WriteLineAsync(System.String,System.String,System.Boolean)">
            <summary>
            Write a given string to a text file on a new line. include the .txt in the path. Method creates new file and directory if either does not exists.
            </summary>
            <param name="path"></param>
            <param name="content"></param>
            <param name="overrideFile"></param>
        </member>
        <member name="M:WinterRose.FileManagement.FileManager.ReadAsync(System.String)">
            <summary>
            Reads all text from the FileStream from beginning to end
            </summary>
            <returns>one conplete string of all text in the file</returns>
            <exception cref="T:System.IO.FileNotFoundException"></exception>
        </member>
        <member name="M:WinterRose.FileManagement.FileManager.ReadLineAsync(System.String,System.Int32)">
            <summary>
            reads the specified line
            </summary>
            <param name="path"></param>
            <param name="lineNumber"></param>
            <returns>the string that exists on the specified line</returns>
            <exception cref="T:System.IO.FileNotFoundException"></exception>
            <exception cref="T:WinterRose.FileManagement.LineNumberTooGreatException"></exception>
        </member>
        <member name="M:WinterRose.FileManagement.FileManager.ReadAllLinesAsync(System.String)">
            <summary>
            reads all lines in the file
            </summary>
            <param name="path"></param>
            <returns>a string array of all lines</returns>
            <exception cref="T:System.IO.FileNotFoundException"></exception>
        </member>
        <member name="M:WinterRose.FileManagement.FileManager.CreateFile(System.String)">
            <summary>
            Creates a new file with the given path and disposes its connection to it immidiately. if the full path does not exist, it creates it
            </summary>
            <param name="Path"></param>
        </member>
        <member name="M:WinterRose.FileManagement.FileManager.ZipDirectory(System.String,System.String,System.IO.Compression.CompressionLevel,System.Boolean)">
            <summary>
            Zips the given directory, and places the created zip file in the given destination path
            </summary>
            <param name="sourceDirectory"></param>
            <param name="archiveDestinationPath"></param>
            <param name="compressionLevel"></param>
            <param name="overrideExistingFile"></param>
        </member>
        <member name="M:WinterRose.FileManagement.FileManager.UnzipDirectory(System.String,System.String,System.Boolean)">
            <summary>
            unzips the given archive, and places the resulting directory at the given path
            </summary>
            <param name="sourceArchive"></param>
            <param name="destinationDirectoryPath"></param>
            <param name="overrideFiles"></param>
        </member>
        <member name="T:WinterRose.FileManagement.FileOutput">
            <summary>
            Represents the output from a read action from the SnowLibrary. this class can be directly assigned to and from a string. no casting needed.
            </summary>
        </member>
        <member name="M:WinterRose.FileManagement.FileOutput.#ctor(System.String)">
            <summary>
            Creates a new instance of the FileOutput class that contains a populated string
            </summary>
            <param name="s"></param>
        </member>
        <member name="M:WinterRose.FileManagement.FileOutput.#ctor">
            <summary>
            Creates a new instance of the FileOutput class that contains an empty string
            </summary>
        </member>
        <member name="M:WinterRose.FileManagement.FileOutput.RemoveNewlineCharacters">
            <summary>
            Removes any and all <b>\r\n</b> that contain within the FileOutput, then returns it as a string
            </summary>
            <returns></returns>
        </member>
        <member name="M:WinterRose.FileManagement.FileOutput.op_Implicit(WinterRose.FileManagement.FileOutput)~System.String">
            <summary>
            Get the output value as a string
            </summary>
            <param name="f"></param>
        </member>
        <member name="M:WinterRose.FileManagement.FileOutput.op_Implicit(System.String)~WinterRose.FileManagement.FileOutput">
            <summary>
            Get a new FileOutput instance from a given string
            </summary>
            <param name="s"></param>
        </member>
        <member name="T:WinterRose.FileManagement.FileOutputExtensions">
            <summary>
            A class containing helpfull methods for FileOutput handling
            </summary>
        </member>
        <member name="M:WinterRose.FileManagement.FileOutputExtensions.RemoveReadAnomalies(WinterRose.FileManagement.FileOutput[])">
            <summary>
            Removes the Read anomalies from every FileOutput within the array
            </summary>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:WinterRose.FileManagement.FileOutputExtensions.ToStringArray(WinterRose.FileManagement.FileOutput[])">
            <summary>
            turns the complete FileOutput array into a array of strings
            </summary>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:WinterRose.FileManagement.FileOutputExtensions.ToFileOutputArray(System.String[])">
            <summary>
            Creates an array of FileOutput classes from an array of strings
            </summary>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="T:WinterRose.FileManagement.LineNumberTooGreatException">
            <summary>
            Gets thrown when reading for a specific line which does not exist in the given file
            </summary>
        </member>
        <member name="T:WinterRose.MathS">
            <summary>
            Math Extention Methods for all Snow needs
            </summary>
            <summary>
            All extra Math methods Snow needs
            </summary>
        </member>
        <member name="M:WinterRose.MathS.Min(System.Collections.Generic.List{System.Single})">
            <summary>
            Finds the smallest float in the list of floats
            </summary>
            <param name="floats"></param>
            <returns>the smallest float in the list</returns>
        </member>
        <member name="M:WinterRose.MathS.Max(System.Collections.Generic.List{System.Single})">
            <summary>
            Finds the largest float in the list of floats
            </summary>
            <param name="floats"></param>
            <returns>the largest float in the list</returns>
        </member>
        <member name="M:WinterRose.MathS.FloorToInt(System.Double)">
            <summary>
            floors the given double to the nearest integer
            </summary>
            <param name="num">This number will be converted to an integer</param>
            <returns>an integer floored from to the nearest possible whole number</returns>
        </member>
        <member name="M:WinterRose.MathS.FloorToInt(System.Single)">
            <summary>
            floors the given float to the nearest integer
            </summary>
            <param name="num">This number will be converted to an integer</param>
            <returns>an integer floored from to the nearest possible whole number</returns>
        </member>
        <member name="M:WinterRose.MathS.CeilingToInt(System.Double)">
            <summary>
            Raises the given double to the nearest integer
            </summary>
            <param name="num">This number will be converted to an integer</param>
            <returns>an integer raised from to the nearest possible whole number</returns>
        </member>
        <member name="M:WinterRose.MathS.CeilingToInt(System.Single)">
            <summary>
            Raises the given float to the nearest integer
            </summary>
            <param name="num">This number will be convertd to an integer</param>
            <returns>an integer raised from to the nearest possible whole number</returns>
        </member>
        <member name="M:WinterRose.MathS.FloorToInt(System.Decimal)">
            <summary>
            floors the given decumal to the nearest round integer
            </summary>
            <param name="num"></param>
            <returns>the floored number</returns>
        </member>
        <member name="M:WinterRose.MathS.CeilingToInt(System.Decimal)">
            <summary>
            Raises the given decimal to the nearest round integer
            </summary>
            <param name="num"></param>
            <returns>the raised number</returns>
        </member>
        <member name="M:WinterRose.MathS.ConsecutiveNumbers(System.Collections.Generic.List{System.Int32},System.Int32)">
            <summary>
            Clears the list and fills it with numbers starting at 0 up to count - 1
            </summary>
            <param name="nums"></param>
            <param name="count"></param>
            <returns><paramref name="nums"/></returns>
        </member>
        <member name="M:WinterRose.MathS.ConsecutiveNumbers(System.Collections.Generic.List{System.Int32},System.Range)">
            <summary>
            Clears the list and fills it with numbers spanning between that of <paramref name="range"/>
            </summary>
            <param name="nums"></param>
            <param name="range"></param>
            <returns><paramref name="nums"/></returns>
        </member>
        <member name="M:WinterRose.MathS.GetHexadecimal(System.Int32)">
            <summary>
            Gets the hexadecimal value from the given int
            </summary>
            <param name="num"></param>
            <returns></returns>
        </member>
        <member name="M:WinterRose.MathS.GetNumber(System.String)">
            <summary>
            gets the integer value from the given hexadecimal
            </summary>
            <param name="hexadecimal"></param>
            <returns></returns>
        </member>
        <member name="M:WinterRose.MathS.GetPersentage(System.Double,System.Double,System.Int32)">
            <summary>
            Get the persentage based on the given parameters
            </summary>
            <param name="current"></param>
            <param name="max"></param>
            <param name="decimals"></param>
            <returns>the persentage calculated from the given parameters</returns>
        </member>
        <member name="M:WinterRose.MathS.GetPersentage(System.Int32,System.Double,System.Int32)">
            <summary>
            Get the persentage based on the given parameters
            </summary>
            <param name="current"></param>
            <param name="max"></param>
            <param name="decimals"></param>
            <returns>the persentage calculated from the given parameters</returns>
        </member>
        <member name="M:WinterRose.MathS.GetPersentage(System.Double,System.Int32,System.Int32)">
            <summary>
            Get the persentage based on the given parameters
            </summary>
            <param name="current"></param>
            <param name="max"></param>
            <param name="decimals"></param>
            <returns>the persentage calculated from the given parameters</returns>
        </member>
        <member name="M:WinterRose.MathS.GetPersentage(System.Single,System.Single,System.Int32)">
            <summary>
            Get the persentage based on the given parameters
            </summary>
            <param name="current"></param>
            <param name="max"></param>
            <param name="decimals"></param>
            <returns>the persentage calculated from the given parameters</returns>
        </member>
        <member name="M:WinterRose.MathS.GetPersentage(System.Single,System.Double,System.Int32)">
            <summary>
            Get the persentage based on the given parameters
            </summary>
            <param name="current"></param>
            <param name="max"></param>
            <param name="decimals"></param>
            <returns>the persentage calculated from the given parameters</returns>
        </member>
        <member name="M:WinterRose.MathS.GetPersentage(System.Double,System.Single,System.Int32)">
            <summary>
            Get the persentage based on the given parameters
            </summary>
            <param name="current"></param>
            <param name="max"></param>
            <param name="decimals"></param>
            <returns>the persentage calculated from the given parameters</returns>
        </member>
        <member name="M:WinterRose.MathS.GetPersentage(System.Int32,System.Single,System.Int32)">
            <summary>
            Get the persentage based on the given parameters
            </summary>
            <param name="current"></param>
            <param name="max"></param>
            <param name="decimals"></param>
            <returns>the persentage calculated from the given parameters</returns>
        </member>
        <member name="M:WinterRose.MathS.GetPersentage(System.Single,System.Int32,System.Int32)">
            <summary>
            Get the persentage based on the given parameters
            </summary>
            <param name="current"></param>
            <param name="max"></param>
            <param name="decimals"></param>
            <returns>the persentage calculated from the given parameters</returns>
        </member>
        <member name="M:WinterRose.MathS.GetPersentage(System.Int32,System.Int32,System.Int32)">
            <summary>
            Get the persentage based on the given parameters
            </summary>
            <param name="current"></param>
            <param name="max"></param>
            <param name="decimals"></param>
            <returns>the persentage calculated from the given parameters</returns>
        </member>
        <member name="F:WinterRose.Networking.UDPClient.OnServerMessageRecieved">
            <summary>
            Gets invoked when a message has been recieved from the server
            </summary>
        </member>
        <member name="M:WinterRose.Networking.UDPClient.StartListening">
            <summary>
            Makes it this client listenes for any messages from the server
            </summary>
        </member>
        <member name="T:WinterRose.Networking.UDPServer">
            <summary>
            A UDP server that can be used to send and receive messages.
            </summary>
        </member>
        <member name="F:WinterRose.Networking.UDPServer.Port">
            <summary>
            the port this server runs on
            </summary>
        </member>
        <member name="F:WinterRose.Networking.UDPServer.OnMessageRecieved">
            <summary>
            Gets invoked when a new message is recieved.
            </summary>
        </member>
        <member name="M:WinterRose.Networking.UDPServer.#ctor(System.Int32)">
            <summary>
            Creates a new UDP server.
            </summary>
            <param name="port"></param>
        </member>
        <member name="M:WinterRose.Networking.UDPServer.StartServer">
            <summary>
            Starts the server
            </summary>
        </member>
        <member name="M:WinterRose.Networking.UDPServer.SendAsync(System.String,System.Net.EndPoint)">
            <summary>
            Sends bytes to the specified endpoint.
            </summary>
            <param name="message"></param>
            <param name="endpoint"></param>
            <returns></returns>
        </member>
        <member name="T:WinterRose.Serialization.IncludePropertiesForFieldAttribute">
            <summary>
            Represents an attribute that can be used to include properties in class fields in the serialization process
            </summary>
        </member>
        <member name="T:WinterRose.Serialization.ExcludeFromSerializationAttribute">
            <summary>
            Makes sure that when serializing or deserializing this field will always be ignore
            </summary>
        </member>
        <member name="T:WinterRose.Serialization.IncludeWithSerializationAttribute">
            <summary>
            Tells the serializer to include this property when handling its declaring class
            </summary>
        </member>
        <member name="T:WinterRose.Serialization.IncludePrivateFieldsAttribute">
            <summary>
            Tells the serializer to use the private fields within this class or struct even if the passed setting states not to include them
            </summary>
        </member>
        <member name="T:WinterRose.Serialization.IncludeAllPropertiesAttribute">
            <summary>
            Tells the serializer to include all properties in the given class or struct even if they do not have the <b>IncludeWithSerializationAttribute</b> attribute
            </summary>
        </member>
        <member name="T:WinterRose.Serialization.SerializeAsAttribute">
            <summary>
            Tells the serializer to serialize this class as the given type, even if the serializer would normally serialize it as a different type
            </summary>
        </member>
        <member name="M:WinterRose.Serialization.SerializeAsAttribute.#ctor(System.Type)">
            <summary>
            Create a new instance of this attribute type
            </summary>
            <param name="type"></param>
        </member>
        <member name="P:WinterRose.Serialization.SerializeAsAttribute.Type">
            <summary>
            The type this class should be serialized as
            </summary>
        </member>
        <member name="T:WinterRose.Serialization.SnowSerializer">
            <summary>
            Provides methods for the Serializing and Deserializing to and from the Snow-Format. it can be used to save and load data for use after a program reboot
            </summary>
        </member>
        <member name="M:WinterRose.Serialization.SnowSerializer.SerializeWIP``1(``0,WinterRose.Serialization.SerializerSettings)">
            <summary>
            WIP... do not use
            </summary>
            <typeparam name="T"></typeparam>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:WinterRose.Serialization.SnowSerializer.DeserializeWIP``1(System.String,System.Boolean,WinterRose.Serialization.SerializerSettings)">
            <summary>
            WIP... do not use
            </summary>
            <typeparam name="T"></typeparam>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="T:WinterRose.Serialization.SerializerSettings">
            <summary>
            Settings for the serializer. these settings are only used for operations on a collection of classes. they are not used for operations on single classes.
            </summary>
        </member>
        <member name="P:WinterRose.Serialization.SerializerSettings.ProgressReporter">
            <summary>
            the action that is called wheneve the serializer handled items. this number can be set at <see cref="P:WinterRose.Serialization.SerializerSettings.ReportEvery"/> -- <b>NOTE:</b> this only happens on lists and arrays. 
            </summary>
        </member>
        <member name="P:WinterRose.Serialization.SerializerSettings.ReportEvery">
            <summary>
            how often <see cref="P:WinterRose.Serialization.SerializerSettings.ProgressReporter"/> should be invoked when serializing or deserialzing
            </summary>
        </member>
        <member name="F:WinterRose.Serialization.SerializerSettings.LudicrusMode">
            <summary>
            Tells the serializer to stress the CPU as much as it possibly can. This can hurt the speed of the operation on lower end machines
            </summary>
        </member>
        <member name="F:WinterRose.Serialization.SerializerSettings.theadsToUse">
            <summary>
            The number, between 1 and 32, of how many threads the serializer may use to serialize or deserialize items in a list at once. 1 item per thread will be serialized or deserialized at a time.
            </summary>
        </member>
        <member name="T:WinterRose.Serialization.InvalidArgumentException">
            <summary>
            Gets thrown when an argument is invalid
            </summary>
        </member>
        <member name="T:WinterRose.Serialization.TypeNotFoundException">
            <summary>
            Gets thrown when a type is not found when using the serializer
            </summary>
        </member>
        <member name="T:WinterRose.Serialization.FieldNotSupportedException">
            <summary>
            Gets thrown when a field is not supported by the serializer
            </summary>
        </member>
        <member name="T:WinterRose.Serialization.FieldNotFoundException">
            <summary>
            Gets thrown when a field is not found within the current handling class, but is present in the serialized data
            </summary>
        </member>
        <member name="T:WinterRose.Serialization.SerializationFailedException">
            <summary>
            Gets thrown when anything fails when serializing
            </summary>
        </member>
        <member name="T:WinterRose.Serialization.DeserializationFailedException">
            <summary>
            Gets thrown when anything fails when deserializing
            </summary>
        </member>
        <member name="T:WinterRose.ProgressReporter">
            <summary>
            Used to report the progress of serializing or deserializing
            </summary>
        </member>
        <member name="P:WinterRose.ProgressReporter.Progress">
            <summary>
            the percentage of completed entries
            </summary>
        </member>
        <member name="P:WinterRose.ProgressReporter.Message">
            <summary>
            a descriptive message 
            </summary>
        </member>
        <member name="M:WinterRose.ProgressReporter.op_Implicit(WinterRose.ProgressReporter)~System.String">
            <summary>
            Gets the message of progress reporter
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:WinterRose.ProgressReporter.op_Implicit(WinterRose.ProgressReporter)~System.Double">
            <summary>
            get the persentage value of the progress reporter
            </summary>
            <param name="e"></param>
        </member>
        <member name="T:WinterRose.ActivatorExtra">
            <summary>
            Provides extra methods for creating instances of types. Works in conjunction with the <see cref="T:WinterRose.DefaultArgumentsAttribute"/>.
            </summary>
        </member>
        <member name="M:WinterRose.ActivatorExtra.CreateInstance(System.Type)">
            <summary>
            Creates an instance of the given generic type. The type must have a parameterless constructor, 
            or a constructor with the <see cref="T:WinterRose.DefaultArgumentsAttribute"/>.
            </summary>
            <returns>The created object. if the type has no parameterless constructor, 
            and no constructor with the <see cref="T:WinterRose.DefaultArgumentsAttribute"/>, returns null.</returns>
        </member>
        <member name="M:WinterRose.ActivatorExtra.CreateInstance``1">
            <summary>
            Creates an instance of the given generic type. The type must have a parameterless constructor, 
            or a constructor with the <see cref="T:WinterRose.DefaultArgumentsAttribute"/>.
            </summary>
            <returns>The created object. if the type has no parameterless constructor, 
            and no constructor with the <see cref="T:WinterRose.DefaultArgumentsAttribute"/>, returns null.</returns>
        </member>
        <member name="M:WinterRose.ActivatorExtra.CreateInstance(System.Type,System.Int32)">
            <summary>
            Creates an instance of the given generic type. The type must have a parameterless constructor, 
            or a constructor with the <see cref="T:WinterRose.DefaultArgumentsAttribute"/>.<br></br>
            With <paramref name="constructorIndex"/> you can specify which constructor to use out of the valid constructors. <b>the constructors are sorted on their position in the script</b>
            </summary>
            <param name="type"></param>
            <param name="constructorIndex">Index is zero-based.</param>
            <returns>The created object. if the type has no parameterless constructor, 
            and no constructor with the <see cref="T:WinterRose.DefaultArgumentsAttribute"/>, returns null.</returns>
        </member>
        <member name="M:WinterRose.ActivatorExtra.CreateInstance``1(System.Int32)">
            <summary>
            Creates an instance of the given generic type. The type must have a parameterless constructor, 
            or a constructor with the <see cref="T:WinterRose.DefaultArgumentsAttribute"/>.<br></br>
            With <paramref name="constructorIndex"/> you can specify which constructor to use out of the valid constructors. <b>the constructors are sorted on their position in the script</b>
            </summary>
            <param name="constructorIndex">Index is zero-based.</param>
            <returns>The created object. If </returns>
        </member>
        <member name="M:WinterRose.ActivatorExtra.CreateInstanceOf(System.String,System.String,System.String)">
            <summary>
            Creates an instance of the type who's type and assembly names are given. optionally filters on namespaces aswell.
            </summary>
            <param name="typeName">the name of the type</param>
            <param name="assemblyName">the name of the assembly</param>
            <param name="namespaceName">the namespace</param>
            <returns>An instance of the found type. or null if noe type was found.</returns>
        </member>
        <member name="T:WinterRose.DefaultArgumentsAttribute">
            <summary>
            this attribute may provide default constructor arguments. Only works if any of the following methods are used:<br></br><br></br>
            
            <see cref="M:WinterRose.ActivatorExtra.CreateInstance(System.Type)"/><br></br>
            <see cref="M:WinterRose.ActivatorExtra.CreateInstance(System.Type,System.Int32)"/><br></br>
            <see cref="M:WinterRose.ActivatorExtra.CreateInstance``1"/><br></br>
            <see cref="M:WinterRose.ActivatorExtra.CreateInstance``1(System.Int32)"/>
            </summary>
        </member>
        <member name="T:WinterRose.EnumeratorExtentions">
            <summary>
            Provides extention features for Foreach loops
            </summary>
        </member>
        <member name="M:WinterRose.EnumeratorExtentions.GetEnumerator(System.Range)">
            <summary>
            Gets a custom enumerator for a range
            </summary>
            <param name="range"></param>
            <returns></returns>
        </member>
        <member name="M:WinterRose.EnumeratorExtentions.GetEnumerator(System.Int32)">
            <summary>
            Gets a custom enumerator for a single number
            </summary>
            <param name="number"></param>
            <returns></returns>
        </member>
        <member name="T:WinterRose.CustomIntEnumerator">
            <summary>
            Provides enumerations on a range or single number
            </summary>
        </member>
        <member name="M:WinterRose.CustomIntEnumerator.#ctor(System.Range)">
            <summary>
            Creates a new object of this struct
            </summary>
            <param name="range"></param>
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="M:WinterRose.CustomIntEnumerator.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new object of this struct
            </summary>
            <param name="range"></param>
        </member>
        <member name="M:WinterRose.CustomIntEnumerator.MoveNext">
            <summary>
            Moves the current value to the next position
            </summary>
            <returns></returns>
        </member>
        <member name="P:WinterRose.CustomIntEnumerator.Current">
            <summary>
            The current value
            </summary>
        </member>
        <member name="T:WinterRose.MutableString">
            <summary>
            Represents a mutable string
            </summary>
        </member>
        <member name="P:WinterRose.MutableString.IsDisposed">
            <summary>
            Gets whether this Mutable String is disposed
            </summary>
        </member>
        <member name="P:WinterRose.MutableString.Length">
            <summary>
            Gets the length of this Mutable String
            </summary>
        </member>
        <member name="M:WinterRose.MutableString.#ctor">
            <summary>
            Creates a new instance of the MutableString struct
            </summary>
        </member>
        <member name="M:WinterRose.MutableString.#ctor(System.String)">
            <summary>
            Creates a new instance of the MutableString struct, using the given value as the initial value
            </summary>
        </member>
        <member name="M:WinterRose.MutableString.op_Implicit(System.String)~WinterRose.MutableString">
            <summary>
            Creates a <see cref="T:WinterRose.MutableString"/> from a standard <see cref="T:System.String"/>
            </summary>
            <param name="s"></param>
        </member>
        <member name="M:WinterRose.MutableString.op_Implicit(WinterRose.MutableString)~System.String">
            <summary>
            Creates a standard <see cref="T:System.String"/> from a <see cref="T:WinterRose.MutableString"/>
            </summary>
            <param name="s"></param>
        </member>
        <member name="M:WinterRose.MutableString.op_Implicit(WinterRose.MutableString)~System.ReadOnlySpan{System.Char}">
            <summary>
            Implicitly converts the MutableString into a <see cref="T:System.ReadOnlySpan`1"/> of type <seealso cref="T:System.Char"/>
            </summary>
            <param name="s"></param>
        </member>
        <member name="M:WinterRose.MutableString.op_Addition(WinterRose.MutableString,System.Char)">
            <summary>
            Adds the given character to this mutable string
            </summary>
            <param name="s"></param>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="M:WinterRose.MutableString.op_Addition(WinterRose.MutableString,System.String)">
            <summary>
            Adds the given string to this Mutable String
            </summary>
            <param name="s"></param>
            <param name="text"></param>
            <returns>the modified Mutable String</returns>
        </member>
        <member name="M:WinterRose.MutableString.Append(WinterRose.MutableString)">
            <summary>
            Appends the given text to this Mutable String
            </summary>
            <param name="text"></param>
        </member>
        <member name="M:WinterRose.MutableString.Append(System.Char)">
            <summary>
            Appends the given character to this Mutable String
            </summary>
            <param name="c"></param>
        </member>
        <member name="M:WinterRose.MutableString.StartsWith(WinterRose.MutableString)">
            <summary>
            Checks if the given Mutable String starts with the given range of characters
            </summary>
            <param name="text"></param>
            <returns>True if the first characters of this Mutable String match the given text</returns>
        </member>
        <member name="M:WinterRose.MutableString.StartsWith(System.Char)">
            <summary>
            Checks if the given Mutable String starts with the given character
            </summary>
            <returns>True if the first character is the given character, false otherwise</returns>
        </member>
        <member name="M:WinterRose.MutableString.EndsWith(WinterRose.MutableString)">
            <summary>
            Checks if this Mutable String ends with the specified range of characters
            </summary>
            <param name="text"></param>
            <returns></returns>
        </member>
        <member name="M:WinterRose.MutableString.Prepend(WinterRose.MutableString)">
            <summary>
            Prepends the given text to this Mutable String
            </summary>
            <param name="text"></param>
        </member>
        <member name="M:WinterRose.MutableString.Split(System.Char,System.StringSplitOptions)">
            <summary>
            Splits the <see cref="T:WinterRose.MutableString"/> into multiple parts based on the given character
            </summary>
            <param name="seperator"></param>
            <param name="options"></param>
            <returns></returns>
        </member>
        <member name="M:WinterRose.MutableString.Split(WinterRose.MutableString,System.StringSplitOptions)">
            <summary>
            Splits the Mutable String based on the given seperator string
            </summary>
            <param name="seperator"></param>
            <param name="options"></param>
            <returns>an array of <see cref="T:WinterRose.MutableString"/> containing the data</returns>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:WinterRose.MutableString.Contains(System.Char)">
            <summary>
            Checks if the given character consists within this Mutable String
            </summary>
            <param name="c"></param>
            <returns>true if the character is contained within this Mutable String,otherwise false</returns>
        </member>
        <member name="M:WinterRose.MutableString.Contains(WinterRose.MutableString)">
            <summary>
            Checks if the given range of characters exists within this Mutable String
            </summary>
            <param name="text"></param>
            <returns></returns>
        </member>
        <member name="M:WinterRose.MutableString.Clear">
            <summary>
            Clears this MutableString
            </summary>
            <returns>The same instance with the applied changes</returns>
        </member>
        <member name="M:WinterRose.MutableString.TrimStart(System.Char)">
            <summary>
            Trims the given character from the start of the sequence
            </summary>
            <param name="c"></param>
            <returns>The same instance with the applied changes</returns>
        </member>
        <member name="M:WinterRose.MutableString.TrimStart(WinterRose.MutableString)">
            <summary>
            Trims the specified sequence of character from the start of this Mutable String
            </summary>
            <param name="s">The sequence of characters that will be trimmed</param>
            <returns>The same instance with the applied changes</returns>
        </member>
        <member name="M:WinterRose.MutableString.TrimEnd(System.Char)">
            <summary>
            Trims the given character from the end of the sequence
            </summary>
            <param name="c"></param>
            <returns>The same instance with the applied changes</returns>
        </member>
        <member name="M:WinterRose.MutableString.TrimEnd(WinterRose.MutableString)">
            <summary>
            Trims the specified sequence of characters from the end of this Mutable String
            </summary>
            <param name="s">The sequence of characters that will be trimmed</param>
            <returns>The same instance with the applied changes</returns>
        </member>
        <member name="M:WinterRose.MutableString.Trim">
            <summary>
            Trims all whitespaces before and after any text
            </summary>
            <returns>The same instance with the applied changes</returns>
        </member>
        <member name="M:WinterRose.MutableString.TrimStart">
            <summary>
            Trims all whitespaces from the start of this sequence
            </summary>
            <returns>The same instance with the applied changes</returns>
        </member>
        <member name="M:WinterRose.MutableString.TrimEnd">
            <summary>
            Trims all whitespaces from the end of this sequence
            </summary>
            <returns>The same instance with the applied changes</returns>
        </member>
        <member name="M:WinterRose.MutableString.Base64Encode">
            <summary>
            Converts the sequence of characters into a base64 string. <br></br><b>Notice:</b> this creates a normal string instance and not a <see cref="T:WinterRose.MutableString"/>;
            </summary>
            <returns></returns>
        </member>
        <member name="M:WinterRose.MutableString.Base64Decode">
            <summary>
            Converts the sequence of base64 characters into a normal string. <br></br><b>Notice:</b> this creates a normal string instance and not a <see cref="T:WinterRose.MutableString"/>;
            </summary>
            <returns></returns>
        </member>
        <member name="P:WinterRose.MutableString.Item(System.Int32)">
            <summary>
            Indexes and finds the character at the specified index
            </summary>
            <param name="index"></param>
            <returns>the found character</returns>
            <exception cref="T:System.IndexOutOfRangeException">thrown if the index is out of range</exception>
        </member>
        <member name="P:WinterRose.MutableString.Item(System.Range)">
            <summary>
            Gets a range of characters of this Mutable string.
            </summary>
            <param name="index"></param>
            <returns>A new Mutable string containing the characters of the given range</returns>
        </member>
        <member name="M:WinterRose.MutableString.ReverseOrder">
            <summary>
            Exactly reverses the order of this Mutable String. 
            </summary>
            <returns>The same instance with the applied changes</returns>
        </member>
        <member name="M:WinterRose.MutableString.IndexOf(System.Char)">
            <summary>
            Gets the index of the specified character.
            </summary>
            <param name="c"></param>
            <returns>The index at which the character given exists. or 0 if it does not exist in this Mutable String</returns>
        </member>
        <member name="M:WinterRose.MutableString.IsNullOrWhitespace">
            <summary>
            Checks if this Mutable string is null, empty, or consists of only whitespace characters
            </summary>
            <returns>True if this Mutable string is null, empty, or consists of only whitespace characters, otherwise false</returns>
        </member>
        <member name="M:WinterRose.MutableString.IsNullOrEmpty">
            <summary>
            Checks if this Mutable string is null or empty
            </summary>
            <returns>True if this Mutable string is null or empty, otherwise false</returns>
        </member>
        <member name="M:WinterRose.MutableString.GetEnumerator">
            <summary>
            Gets the enumerator that hold all characters
            </summary>
            <returns></returns>
        </member>
        <member name="M:WinterRose.MutableString.ToString">
            <summary>
            Creates a standard <see cref="T:System.String"/> interpretation of this Mutable String
            </summary>
            <returns>A <see cref="T:System.String"/> representation of this Mutable String</returns>
        </member>
        <member name="M:WinterRose.MutableString.Dispose">
            <summary>
            Disposes this Mutable String
            </summary>
        </member>
        <member name="T:WinterRose.ActionQueuer">
            <summary>
            Allows for queueing of Methods with no arguments and no return values.
            </summary>
        </member>
        <member name="P:WinterRose.ActionQueuer.Count">
            <summary>
            Gets the number of methods in the queue
            </summary>
        </member>
        <member name="M:WinterRose.ActionQueuer.#ctor">
            <summary>
            Creates a new instance of the ActionQueuer class
            </summary>
        </member>
        <member name="M:WinterRose.ActionQueuer.Add(System.Action)">
            <summary>
            Adds a new action to the queue
            </summary>
            <param name="action">The action that will be added</param>
        </member>
        <member name="M:WinterRose.ActionQueuer.StartQueue">
            <summary>
            Starts the queue
            </summary>
            <returns>The completed task</returns>
        </member>
        <member name="T:WinterRose.ActionQueuer`1">
            <summary>
            allows for queueing of Methods with one argument and no return values.
            </summary>
            <typeparam name="T1">Argument 1</typeparam>
        </member>
        <member name="M:WinterRose.ActionQueuer`1.#ctor">
            <summary>
            Creates a new instance of the ActionQueuer class
            </summary>
        </member>
        <member name="P:WinterRose.ActionQueuer`1.Count">
            <summary>
            Gets the number of methods in the queue
            </summary>
        </member>
        <member name="M:WinterRose.ActionQueuer`1.Add(WinterRose.ActionQueuer{`0}.QueueArgumentCarrier)">
            <summary>
            Adds a new action to the queue
            </summary>
            <param name="argument">The action that will be added, alongside its argument</param>
        </member>
        <member name="M:WinterRose.ActionQueuer`1.StartQueue">
            <summary>
            Starts the queue
            </summary>
            <returns>The completed task</returns>
        </member>
        <member name="T:WinterRose.ActionQueuer`1.QueueArgumentCarrier">
            <summary>
            allows for the carrying of arguments to actions in the queue
            </summary>
        </member>
        <member name="M:WinterRose.ActionQueuer`1.QueueArgumentCarrier.#ctor(System.Action{`0},`0)">
            <summary>
            Creates a new instance of the <b>QueueArgumentCarrier</b> class
            </summary>
            <param name="action"></param>
            <param name="argument"></param>
        </member>
        <member name="M:WinterRose.ActionQueuer`1.QueueArgumentCarrier.op_Implicit(WinterRose.ActionQueuer{`0}.QueueArgumentCarrier)~`0">
            <summary>
            Gets the arguments value
            </summary>
            <param name="argument"></param>
        </member>
        <member name="T:WinterRose.ActionQueuer`2">
            <summary>
            allows for queueing of Methods with two arguments, and no return types. Contact the author of this library if you wish to use more arguments
            </summary>
            <typeparam name="T1">argument 1</typeparam>
            <typeparam name="T2">argument 2</typeparam>
        </member>
        <member name="P:WinterRose.ActionQueuer`2.Count">
            <summary>
            Gets the number of methods in the queue
            </summary>
        </member>
        <member name="M:WinterRose.ActionQueuer`2.#ctor">
            <summary>
            Creates a new instance of the ActionQueuer class
            </summary>
        </member>
        <member name="M:WinterRose.ActionQueuer`2.Add(WinterRose.ActionQueuer{`0,`1}.QueueArgumentCarrier)">
            <summary>
            Adds a new action to the queue
            </summary>
            <param name="arguments">The action that will be added, alongside its argument</param>
        </member>
        <member name="M:WinterRose.ActionQueuer`2.StartQueue">
            <summary>
            Starts the queue
            </summary>
            <returns>The completed task</returns>
        </member>
        <member name="T:WinterRose.ActionQueuer`2.QueueArgumentCarrier">
            <summary>
            Allows for the carrying of a Action with arguments
            </summary>
        </member>
        <member name="M:WinterRose.ActionQueuer`2.QueueArgumentCarrier.#ctor(System.Action{`0,`1},`0,`1)">
            <summary>
            allows for the carrying of arguments to actions in the queue
            </summary>
        </member>
        <member name="M:WinterRose.ActionQueuer`2.QueueArgumentCarrier.op_Implicit(WinterRose.ActionQueuer{`0,`1}.QueueArgumentCarrier)~`0">
            <summary>
            Gets the first argument
            </summary>
            <param name="argument"></param>
        </member>
        <member name="M:WinterRose.ActionQueuer`2.QueueArgumentCarrier.op_Implicit(WinterRose.ActionQueuer{`0,`1}.QueueArgumentCarrier)~`1">
            <summary>
            Gets the second argument
            </summary>
            <param name="argument"></param>
        </member>
        <member name="T:WinterRose.FuncQueuer`1">
            <summary>
            allows for queueing of Methods with no arguments and a return value
            </summary>
            <typeparam name="TReturnType">Return value</typeparam>
        </member>
        <member name="P:WinterRose.FuncQueuer`1.Count">
            <summary>
            Gets the number of methods in the queue
            </summary>
        </member>
        <member name="M:WinterRose.FuncQueuer`1.#ctor">
            <summary>
            Creates a new instance of the FuncQueuer class
            </summary>
        </member>
        <member name="M:WinterRose.FuncQueuer`1.Add(WinterRose.FuncQueuer{`0}.QueueFuncArgumentCarrier)">
            <summary>
            Adds the given Func to the queue
            </summary>
            <param name="arguments">the func that will be added, along side its callback action</param>
        </member>
        <member name="M:WinterRose.FuncQueuer`1.StartQueue(System.Boolean)">
            <summary>
            Starts the queue
            </summary>
            <param name="waitForCallback"></param>
            <returns>The completed task</returns>
        </member>
        <member name="T:WinterRose.FuncQueuer`1.QueueFuncArgumentCarrier">
            <summary>
            Allows for the carrying of a func with a callback action and arguments
            </summary>
        </member>
        <member name="M:WinterRose.FuncQueuer`1.QueueFuncArgumentCarrier.#ctor(System.Func{`0},System.Action{`0})">
            <summary>
            Creates a new instance of the <b>QueueFuncArgumentCarrier</b> class
            </summary>
            <param name="func"></param>
            <param name="callBack"></param>
        </member>
        <member name="T:WinterRose.FuncQueuer`2">
            <summary>
            allows for queueing of Methods with one argument and a return value.
            </summary>
            <typeparam name="TArgument1">argument 1</typeparam>
            <typeparam name="TReturnType">return value</typeparam>
        </member>
        <member name="P:WinterRose.FuncQueuer`2.Count">
            <summary>
            Gets the number of methods currently in the queue
            </summary>
        </member>
        <member name="M:WinterRose.FuncQueuer`2.Add(WinterRose.FuncQueuer{`0,`1}.QueueFuncArgumentCarrier)">
            <summary>
            adds the specified func with its callback action and its argument to the queue
            </summary>
            <param name="arguments"></param>
        </member>
        <member name="M:WinterRose.FuncQueuer`2.StartQueue">
            <summary>
            Starts the queue
            </summary>
            <returns>The Completed Task</returns>
        </member>
        <member name="T:WinterRose.FuncQueuer`2.QueueFuncArgumentCarrier">
            <summary>
            Allows for the carrying of a func with a callback action and arguments
            </summary>
        </member>
        <member name="M:WinterRose.FuncQueuer`2.QueueFuncArgumentCarrier.#ctor(System.Func{`0,`1},`0,System.Action{`1})">
            <summary>
            Creates a new instance of the <b>QueueFuncArgumentCarrier</b> class
            </summary>
            <param name="func"></param>
            <param name="callBack"></param>
        </member>
        <member name="M:WinterRose.FuncQueuer`2.QueueFuncArgumentCarrier.op_Implicit(WinterRose.FuncQueuer{`0,`1}.QueueFuncArgumentCarrier)~`0">
            <summary>
            Gets the argument
            </summary>
            <param name="argument"></param>
        </member>
        <member name="T:WinterRose.FuncQueuer`3">
            <summary>
            Contact the author of this library if you wish to use more arguments
            </summary>
            <typeparam name="TArgument1">argument 1</typeparam>
            <typeparam name="TArgument2">argument 2</typeparam>
            <typeparam name="TReturnType">return value</typeparam>
        </member>
        <member name="P:WinterRose.FuncQueuer`3.Count">
            <summary>
            Gets the number of methods currently in the queue
            </summary>
        </member>
        <member name="M:WinterRose.FuncQueuer`3.#ctor">
            <summary>
            Creates a new instance of the FuncQueuer class
            </summary>
        </member>
        <member name="M:WinterRose.FuncQueuer`3.Add(WinterRose.FuncQueuer{`0,`1,`2}.QueueFuncArgumentCarrier)">
            <summary>
            Adds the given func with its callback action and arguments to the queue
            </summary>
            <param name="arguments"></param>
        </member>
        <member name="M:WinterRose.FuncQueuer`3.StartQueue">
            <summary>
            Starts the queue
            </summary>
            <returns>The completed task</returns>
        </member>
        <member name="T:WinterRose.FuncQueuer`3.QueueFuncArgumentCarrier">
            <summary>
            Allows for the carrying of a func with a callback action and arguments
            </summary>
        </member>
        <member name="M:WinterRose.FuncQueuer`3.QueueFuncArgumentCarrier.#ctor(System.Func{`0,`1,`2},`0,`1,System.Action{`2})">
            <summary>
            Creates a new instance of the FuncQueuer class
            </summary>
        </member>
        <member name="M:WinterRose.FuncQueuer`3.QueueFuncArgumentCarrier.op_Implicit(WinterRose.FuncQueuer{`0,`1,`2}.QueueFuncArgumentCarrier)~`0">
            <summary>
            Gets the first argument
            </summary>
            <param name="argument"></param>
        </member>
        <member name="M:WinterRose.FuncQueuer`3.QueueFuncArgumentCarrier.op_Implicit(WinterRose.FuncQueuer{`0,`1,`2}.QueueFuncArgumentCarrier)~`1">
            <summary>
            Gets the second argument
            </summary>
            <param name="argument"></param>
        </member>
        <member name="T:WinterRose.SnowUtils">
            <summary>
            Suggestions for this class are welcome. please report them the the Author, <b>TheSnowOwl</b>
            </summary>
        </member>
        <member name="M:WinterRose.SnowUtils.ToStringArray(WinterRose.MutableString[])">
            <summary>
            Casts the <see cref="T:WinterRose.MutableString"/> array to an array of <see cref="T:System.String"/>
            </summary>
            <param name="array"></param>
            <returns></returns>
        </member>
        <member name="M:WinterRose.SnowUtils.ToMutableStringArray(System.String[])">
            <summary>
            Casts the <see cref="T:System.String"/> array to an array of <see cref="T:WinterRose.MutableString"/>
            </summary>
            <param name="array"></param>
            <returns></returns>
        </member>
        <member name="M:WinterRose.SnowUtils.CreateList(System.Type)">
            <summary>
            Creates a new list of the given type.
            </summary>
            <param name="t"></param>
            <returns>A dynamic representation of the newly created list. cast this explicitly to the correct list variable if needed</returns>
        </member>
        <member name="M:WinterRose.SnowUtils.GetDirectoryName(System.String)">
            <summary>
            gets the last part of the given path
            </summary>
            <param name="path"></param>
            <returns>the last part of the given path</returns>
        </member>
        <member name="M:WinterRose.SnowUtils.Repeat(System.Action,System.Int32)">
            <summary>
            Repeats the given action the given amount of times.
            </summary>
            <param name="action"></param>
            <param name="times"></param>
        </member>
        <member name="M:WinterRose.SnowUtils.Repeat(System.Action,System.Int32,System.Action{System.Single},System.Int32)">
            <summary>
            Repeats the given action the given amount of times. and invokes the callback method after the action has been repeated the given amount of times.
            </summary>
        </member>
        <member name="M:WinterRose.SnowUtils.Repeat(System.Action{System.UInt64},System.UInt64)">
            <summary>
            Repeats the given action the given amount of times. gives the current iteration number as argument for the action
            </summary>
            <param name="action"></param>
            <param name="times"></param>
        </member>
        <member name="M:WinterRose.SnowUtils.Repeat(System.Action{System.Int32},System.Int32)">
            <summary>
            Repeats the given action the given amount of times. gives the current iteration number as argument for the action
            </summary>
            <param name="action"></param>
            <param name="times"></param>
        </member>
        <member name="M:WinterRose.SnowUtils.Repeat(System.Action,System.Func{System.Boolean},System.Boolean)">
            <summary>
            Repeats the given action until the condition is met. or if 'UntilConditionIsTrue' is set to true, it repeats the action while the condition is met
            </summary>
        </member>
        <member name="M:WinterRose.SnowUtils.RepeatAsync(System.Action,System.Int32)">
            <summary>
            Repeats the given action the given amount of times.
            </summary>
            <param name="action"></param>
            <param name="times"></param>
        </member>
        <member name="M:WinterRose.SnowUtils.RepeatAsync(System.Action,System.Func{System.Boolean},System.Boolean)">
            <summary>
            Repeats the given action until the condition is met. or if 'UntilConditionIsTrue' is set to true, it repeats the action while the condition is met
            </summary>
        </member>
        <member name="M:WinterRose.SnowUtils.ConsecutiveNumbers(System.Int32)">
            <summary>
            creates a list of consecutive numbers
            </summary>
            <param name="count"></param>
            <returns>a new list that counts from 0 to the given count - 1</returns>
        </member>
        <member name="M:WinterRose.SnowUtils.ReverseOrder``1(System.Collections.Generic.List{``0})">
            <summary>
            Creates a new list and populates it with the reversed order of the operated list
            </summary>
            <typeparam name="T"></typeparam>
            <param name="values"></param>
            <returns>A new list with the items of the operated list reversed</returns>
        </member>
        <member name="M:WinterRose.SnowUtils.Count(System.Collections.IEnumerable)">
            <summary>
            Counts the amount of items in the given list
            </summary>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:WinterRose.SnowUtils.ToList(System.Range)">
            <summary>
            Converts the range to a list of integers
            </summary>
            <param name="range"></param>
            <returns>the created list</returns>
        </member>
        <member name="M:WinterRose.SnowUtils.IsUpper(System.Char)">
            <summary>
            Indicates whether the specified character is catagorized as an uppercase letter
            </summary>
            <param name="c"></param>
            <returns>true if the given character is a uppercase letter, otherwise false</returns>
        </member>
        <member name="M:WinterRose.SnowUtils.IsLower(System.Char)">
            <summary>
            Indicates whether the specified character is catagorized as a lowercase letter
            </summary>
            <param name="c"></param>
            <returns>true if the given character is a lower case letter, otherwise false</returns>
        </member>
        <member name="M:WinterRose.SnowUtils.IsNumber(System.Char)">
            <summary>
            Indicates whether the specified character is catagorized as a number
            </summary>
            <param name="c"></param>
            <returns>true if the given character is a number, otherwise false</returns>
        </member>
        <member name="M:WinterRose.SnowUtils.ToUpper(System.Char)">
            <summary>
            Conerts the given letter to its uppercase variant
            </summary>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="M:WinterRose.SnowUtils.ToLower(System.Char)">
            <summary>
            Converts the given letter to its lowercase variant
            </summary>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="M:WinterRose.SnowUtils.IsLetter(System.Char)">
            <summary>
            Indicates whether the given char is a alphabetical letter or not.
            </summary>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="M:WinterRose.SnowUtils.Add``2(System.Collections.Generic.Dictionary{``0,``1},System.Collections.Generic.KeyValuePair{``0,``1})">
            <summary>
            Adds the given Pair to the Dictionary
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="dict"></param>
            <param name="pair"></param>
        </member>
        <member name="M:WinterRose.SnowUtils.MakeString(System.Char[])">
            <summary>
            Sets all the letters in the char array into one single string
            </summary>
            <param name="chars"></param>
        </member>
        <member name="M:WinterRose.SnowUtils.GetRelativeTime(System.DateTime,System.DateTime)">
            <summary>
            Calculates the relative time between the given times
            </summary>
            <param name="time"></param>
            <param name="target"></param>
            <returns>Timespan containing the relative time between the two and whether this time is in the past or not</returns>
        </member>
        <member name="M:WinterRose.SnowUtils.Split``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Splits the given IEnumerable into the given amount of parts. does not keep the order of the enumerable. 
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="parts"></param>
            <returns>a list of all parts</returns>
        </member>
        <member name="M:WinterRose.SnowUtils.Partition``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            determains the most efficient way to create smaller groups of the given IEnumberable and handles upon that conclution but never goes above the max alowed partitions. if put back together into one list it retains the same order (should you handle the items from the first split list to the last)
            </summary>
            <typeparam name="T"></typeparam>
            <returns>an array of lists that has elements of the IEnumberable operated on split between them</returns>
        </member>
        <member name="M:WinterRose.SnowUtils.NextAvalible(System.Collections.Generic.List{System.Int32})">
            <summary>
            finds the first unused <see cref="T:System.Int32"/> from a list
            </summary>
            <param name="list"></param>
            <returns>the next avalible <see cref="T:System.Int32"/> from a list of type  <see cref="T:System.Int32"/></returns>
        </member>
        <member name="M:WinterRose.SnowUtils.NextAvalible``1(System.Collections.Generic.Dictionary{System.Int32,``0})">
            <summary>
            finds the first unused <see cref="T:System.Int32"/> from a Dictionary which has a Key value of type <see cref="T:System.Int32"/>
            </summary>
            <returns>the next avalible <see cref="T:System.Int32"/> from the Dictionary of Keys of type <see cref="T:System.Int32"/></returns>
        </member>
        <member name="M:WinterRose.SnowUtils.Repeat``1(``0,System.Action{``0},System.Int32)">
            <summary>
            Repeats the given action the given amount of times.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="source"></param>
            <param name="action"></param>
            <param name="times"></param>
        </member>
        <member name="M:WinterRose.SnowUtils.Repeat``1(``0,System.Action{``0},System.Func{System.Boolean},System.Boolean)">
            <summary>
            Repeats the given action until the condition is met. or if 'UntilConditionIsTrue' is set to true, it repeats the action while the condition is met
            </summary>
            <typeparam name="T"></typeparam>
            <param name="source"></param>
            <param name="action"></param>
        </member>
        <member name="M:WinterRose.SnowUtils.Foreach``1(``0[],System.Action{``0})">
            <summary>
            executes the given action on every entry in the array
            </summary>
            <typeparam name="T"></typeparam>
            <param name="array"></param>
            <param name="action"></param>
        </member>
        <member name="M:WinterRose.SnowUtils.Foreach``1(``0[],System.Action{``0,System.Int32})">
            <summary>
            executes the given action on every entry in the array. passes the iteration int as the second argument.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="array"></param>
            <param name="action"></param>
        </member>
        <member name="M:WinterRose.SnowUtils.Foreach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            executes the given action on every entry in the Enumerable
            </summary>
            <typeparam name="T"></typeparam>
            <param name="action"></param>
        </member>
        <member name="M:WinterRose.SnowUtils.ForeachAsync``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            executes the given action on every entry in the Enumerable
            </summary>
            <typeparam name="T"></typeparam>
            <param name="action"></param>
            <returns>the list where the given action is preformed on all entries</returns>
        </member>
        <member name="M:WinterRose.SnowUtils.RepeatAsync``1(``0,System.Action{``0},System.Int32)">
            <summary>
            Repeats the given action the given amount of times.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="source"></param>
            <param name="action"></param>
            <param name="times"></param>
        </member>
        <member name="M:WinterRose.SnowUtils.RepeatAsync``1(``0,System.Action{``0},System.Func{System.Boolean},System.Boolean)">
            <summary>
            Repeats the given action until the stop condition is met.
            </summary>
        </member>
        <member name="M:WinterRose.SnowUtils.ForeachAsync``1(``0[],System.Action{``0})">
            <summary>
            executes the given action on every entry in the array
            </summary>
            <typeparam name="T"></typeparam>
            <param name="array"></param>
            <param name="action"></param>
            <returns>the array where the action has executed on all entries</returns>
        </member>
        <member name="M:WinterRose.SnowUtils.Foreach``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0})">
            <summary>
            executes the given action on every entry in the Enumerable
            </summary>
            <typeparam name="T"></typeparam>
            <param name="action"></param>
            <returns>the list where the given action is preformed on all entries</returns>
        </member>
        <member name="M:WinterRose.SnowUtils.Foreach``1(``0[],System.Func{``0,``0})">
            <summary>
            executes the given action on every entry in the array
            </summary>
            <typeparam name="T"></typeparam>
            <param name="array"></param>
            <param name="action"></param>
            <returns>the array where the action has executed on all entries</returns>
        </member>
        <member name="M:WinterRose.SnowUtils.For``1(``0[],System.Func{``0,``0})">
            <summary>
            executes an action on every index of the array. index can be null, the default of the type will be used for this iteration then
            </summary>
            <typeparam name="T"></typeparam>
            <param name="array"></param>
            <param name="action"></param>
            <returns>the array where the action has executed for all indexes</returns>
        </member>
        <member name="M:WinterRose.SnowUtils.ForeachAsync``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0})">
            <summary>
            executes the given action on every entry in the Enumerable
            </summary>
            <returns>the list where the given action is preformed on all entries</returns>
        </member>
        <member name="M:WinterRose.SnowUtils.ForeachAsync``1(``0[],System.Func{``0,``0})">
            <summary>
            executes the given action on every entry in the array
            </summary>
            <typeparam name="T"></typeparam>
            <param name="array"></param>
            <param name="action"></param>
            <returns>the array where the action has executed on all entries</returns>
        </member>
        <member name="M:WinterRose.SnowUtils.ForAsync``1(``0[],System.Func{``0,``0})">
            <summary>
            executes an action on every index of the array. index can be null, the default of the type will be used for this iteration then
            </summary>
            <typeparam name="T"></typeparam>
            <param name="array"></param>
            <param name="action"></param>
            <returns>the array where the action has executed for all indexes</returns>
        </member>
        <member name="T:WinterRose.StringWorker">
            <summary>
            Provides methods to manipulate strings 
            </summary>
        </member>
        <member name="M:WinterRose.StringWorker.ReverseOrder(System.String)">
            <summary>
            reverses the given string
            </summary>
            <param name="input"></param>
            <returns>a new string with its character order exactly reversed</returns>
        </member>
        <member name="M:WinterRose.StringWorker.FirstCapital(System.String)">
            <summary>
            makes the first letter capital while making the rest lowercase
            </summary>
            <param name="source">string to be acted on</param>
            <returns>the manipulated string where all but the first letter are lower case</returns>
        </member>
        <member name="M:WinterRose.StringWorker.FirstCapitalOnAllWords(System.String)">
            <summary>
            Makes all first letters of sections seperated by a space a capital letter
            </summary>
            <param name="source"></param>
            <returns>the manipulated string where every word has its first letter turned into a captial letter</returns>
        </member>
        <member name="M:WinterRose.StringWorker.Base64Encode(System.String)">
            <summary>
            converts the given string to a base64 format
            </summary>
            <param name="plainText"></param>
            <returns>the base64 result from the given string</returns>
        </member>
        <member name="M:WinterRose.StringWorker.Base64Decode(System.String)">
            <summary>
            converts the given base64 format into UTF8 characters
            </summary>
            <param name="base64EncodedData"></param>
            <returns>the UTF8 string result from the given base64 format input</returns>
        </member>
        <member name="M:WinterRose.StringWorker.StringAnimation(System.String,System.Int32)">
            <summary>
            allows easy animation of a string to be shown to the user. combine with <b>Foreach()</b>, <b>ForeachAsync()</b>, or any other foreach loop to attchieve the desired result
            </summary>
            <param name="content"></param>
            <param name="delay"></param>
            <returns>yield returns a string with one extra character than the last until the given <paramref name="content"/> is returned in its fullest</returns>
        </member>
        <member name="M:WinterRose.StringWorker.StringAnimationChar(System.String,System.Int32)">
            <summary>
            allows easy animation of a string to be shown to the user. combine with <b>Foreach()</b>, <b>ForeachAsync()</b>, or any other foreach loop to attchieve the desired result
            </summary>
            <param name="content"></param>
            <param name="delay"></param>
            <returns>yield returns a char taken from the given <paramref name="content"/> until the last char has been returned</returns>
        </member>
        <member name="T:WinterRose.TypeWorker">
            <summary>
            Provides methods for finding a type or method within accessable assembiles, and easy casting to and from default data types
            </summary>
        </member>
        <member name="M:WinterRose.TypeWorker.GetBaseTypesWIP(System.Type)">
            <summary>
            WIP method
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:WinterRose.TypeWorker.Convert(System.Object,System.Type)">
            <summary>
            the same as Convert.ChangeType(object frrom, object To) except this returns a dynamic instead of an object
            </summary>
            <param name="from"></param>
            <param name="to"></param>
            <returns>a dynamic object converted to the given type. or null if converting failed</returns>
        </member>
        <member name="M:WinterRose.TypeWorker.FindType(System.String,System.Reflection.Assembly)">
            <summary>
            Searches for the Type matching to the given name. can pass the assembly as filter for the search
            </summary>
            <returns>The type matching the given name if it is found within the current accessable assemblies. if no matching type is found it returns null</returns>
        </member>
        <member name="M:WinterRose.TypeWorker.FindType(System.String,System.String)">
            <summary>
            Searches for the Type matching to the given name. can pass the assembly as filter for the search. be sure to just give the name of the assembly
            </summary>
            <returns>The type matching the given name if it is found within the given Assembly. if no matching type is found it returns null</returns>
        </member>
        <member name="M:WinterRose.TypeWorker.FindTypesWithAttribute``1">
            <summary>
            Finds all types that have the given attribute.
            </summary>
            <typeparam name="T"></typeparam>
            <returns>An array of types that have the given attribute. if no type has the given attribute it returns an empty array</returns>
        </member>
        <member name="M:WinterRose.TypeWorker.FindType(System.String,System.String,System.String)">
            <summary>
            Searches for the Type matching to the given name. can pass the assembly as filter for the search. be sure to just give the name of the assembly
            </summary>
            <returns>The type matching the given name if it is found within the given Assembly and namespace. if no matching type is found it returns null</returns>
        </member>
        <member name="M:WinterRose.TypeWorker.FindMethod(System.Type,System.String)">
            <summary>
            Searches for a method within the given type that has the given name.
            </summary>
            <param name="containing"></param>
            <param name="name"></param>
            <returns>returns the found method info if a method with the given name is found, otherwise returns null</returns>
        </member>
        <member name="M:WinterRose.TypeWorker.CastPrimitive(System.Object,System.Type,System.Reflection.Assembly,System.String)">
            <summary>
            Casts the given file to the given destination type. should this fail it throws an exception
            </summary>
            <param name="from"></param>
            <param name="to"></param>
            <param name="targetAssembly"></param>
            <param name="targetTypeName"></param>
            <returns>the converted value</returns>
            <exception cref="T:WinterRose.Serialization.TypeNotFoundException"></exception>
            <exception cref="T:WinterRose.FailedToCastTypeException"></exception>
            <exception cref="T:WinterRose.CastTypeNotSupportedException"></exception>
        </member>
        <member name="M:WinterRose.TypeWorker.CastPrimitive``1(System.Object,``0,System.Reflection.Assembly,System.String)">
            <summary>
            Casts the given file to the given destination type. should this fail it throws an exception
            </summary>
            <typeparam name="T"></typeparam>
            <param name="from"></param>
            <param name="to"></param>
            <param name="targetAssembly"></param>
            <param name="targetTypeName"></param>
            <returns>the converted value</returns>
            <exception cref="T:WinterRose.Serialization.TypeNotFoundException"></exception>
            <exception cref="T:WinterRose.FailedToCastTypeException"></exception>
            <exception cref="T:WinterRose.CastTypeNotSupportedException"></exception>
        </member>
        <member name="M:WinterRose.TypeWorker.CastPrimitive``1(System.Object)">
            <summary>
            Casts the given file to the given destination type. should this fail it throws an exception
            </summary>
            <typeparam name="T"></typeparam>
            <param name="from"></param>
            <returns>the converted value</returns>
            <exception cref="T:WinterRose.Serialization.TypeNotFoundException"></exception>
            <exception cref="T:WinterRose.FailedToCastTypeException"></exception>
            <exception cref="T:WinterRose.CastTypeNotSupportedException"></exception>
        </member>
        <member name="M:WinterRose.TypeWorker.TryCastPrimitive``1(System.Object,``0@)">
            <summary>
            Attemts to cast a primitive value to the given cast target
            </summary>
            <typeparam name="T"></typeparam>
            <param name="from"></param>
            <param name="result"></param>
            <returns>true if the operation was successful, otherwise false. puts the result in <paramref name="result"/>. if the operation failed this will be the default value of the specified target type</returns>
        </member>
        <member name="M:WinterRose.TypeWorker.TryCastPrimitive(System.Object,System.Type,System.Object@)">
            <summary>
            Attemts to cast a primitive value to the given cast target
            </summary>
            <typeparam name="T"></typeparam>
            <param name="from"></param>
            <param name="result"></param>
            <returns>true if the operation was successful, otherwise false. puts the result in <paramref name="result"/>. 
            if the operation failed null is returned</returns>
        </member>
        <member name="T:WinterRose.FailedToCastTypeException">
            <summary>
            Gets thrown when casting fails
            </summary>
        </member>
        <member name="T:WinterRose.CastTypeNotSupportedException">
            <summary>
            Gets thrown when destination type is not supported by the <see cref="M:WinterRose.TypeWorker.CastPrimitive``1(System.Object)"/> methods
            </summary>
        </member>
        <member name="T:WinterRose.MethodNotFoundException">
            <summary>
            Gets thrown when a linked method for events when serializing is not found
            </summary>
        </member>
        <member name="T:WinterRose.WorkDistributor">
            <summary>
            Provides an easy way to distribute work across multiple threads
            </summary>
        </member>
        <member name="P:WinterRose.WorkDistributor.FunctionCount">
            <summary>
            Gets the amount of functions added to the WorkDistributor
            </summary>
        </member>
        <member name="M:WinterRose.WorkDistributor.#ctor(System.Int32)">
            <summary>
            Creates a new instance of the WorkDistributor class
            </summary>
            <param name="threads"></param>
        </member>
        <member name="M:WinterRose.WorkDistributor.AddFunction(System.Action)">
            <summary>
            Adds the given function with no arguments or return type to the WorkDistributor
            </summary>
            <param name="action"></param>
        </member>
        <member name="M:WinterRose.WorkDistributor.Clear">
            <summary>
            Removes all functions tied to this WorkDistributor
            </summary>
        </member>
        <member name="M:WinterRose.WorkDistributor.RemoveFunction(System.Action)">
            <summary>
            Removes the given function from the WorkDistributor
            </summary>
            <param name="action"></param>
        </member>
        <member name="M:WinterRose.WorkDistributor.Start">
            <summary>
            Calls all the functions added to the WorkDistributor on the allowed amount of threads. <strong>this does NOT respect the order of the given functions</strong>
            </summary>
            <returns>An 32 bit signed integer conveying information on how many tasks failed</returns>
        </member>
        <member name="M:WinterRose.WorkDistributor.Start(System.Int32)">
            <summary>
            Calls all the functions added to the WorkDistributor on the allowed amount of threads.  <strong>this does NOT respect the order of the given functions</strong>
            </summary>
        </member>
        <member name="M:WinterRose.WorkDistributor.StartAsync">
            <summary>
            Asynchronously calls all the functions added to the WorkDistributor on the allowed amount of threads.  <strong>this does NOT respect the order of the given functions</strong>
            </summary>
        </member>
        <member name="M:WinterRose.WorkDistributor.StartAsync(System.Int32)">
            <summary>
            Asynchronously calls all the functions added to the WorkDistributor on the allowed amount of threads.  <strong>this does NOT respect the order of the given functions</strong>
            </summary>
        </member>
        <member name="T:WinterRose.Vectors.Vector2">
            <summary>
            An object that represents a point in 2D worldspace
            </summary>
        </member>
        <member name="F:WinterRose.Vectors.Vector2.x">
            <summary>
            Vector2 coördinate
            </summary>
        </member>
        <member name="F:WinterRose.Vectors.Vector2.y">
            <summary>
            Vector2 coördinate
            </summary>
        </member>
        <member name="F:WinterRose.Vectors.Vector2.Zero">
            <summary>
            Defines a Vector2 with X and Y values at 0
            </summary>
        </member>
        <member name="M:WinterRose.Vectors.Vector2.#ctor(System.Single,System.Single)">
            <summary>
            poppulated constructor
            </summary>
        </member>
        <member name="M:WinterRose.Vectors.Vector2.#ctor(System.Double,System.Double)">
            <summary>
            Creates a new instance of this Vector2 casting the doubles to floats
            </summary>
        </member>
        <member name="M:WinterRose.Vectors.Vector2.#ctor">
            <summary>
            empty constructor
            </summary>
        </member>
        <member name="P:WinterRose.Vectors.Vector2.Magnitude">
            <summary>
            Gets the magnitude of this vector
            </summary>
        </member>
        <member name="P:WinterRose.Vectors.Vector2.Normalized">
            <summary>
            Gets the normalized vector
            </summary>
        </member>
        <member name="P:WinterRose.Vectors.Vector2.Length">
            <summary>
            Gets the length of the vector
            </summary>
        </member>
        <member name="M:WinterRose.Vectors.Vector2.ToString">
            <summary>
            gets a string representation of this Vector2 object
            </summary>
            <returns></returns>
        </member>
        <member name="M:WinterRose.Vectors.Vector2.Random(System.Int32,System.Int32)">
            <summary>
            generates a vector2 with random values
            </summary>
            <returns>new vector2 where the values xy are randomized</returns>
        </member>
        <member name="M:WinterRose.Vectors.Vector2.Distance(WinterRose.Vectors.Vector2,WinterRose.Vectors.Vector2)">
            <summary>
            gets the distance between 2 vector2 points
            </summary>
            <returns>a float with the distance between the 2 points in a straight line</returns>
        </member>
        <member name="M:WinterRose.Vectors.Vector2.Normalize">
            <summary>
            Normalizes the vector
            </summary>
            <returns>The nomalized vector</returns>
        </member>
        <member name="M:WinterRose.Vectors.Vector2.Normalize(WinterRose.Vectors.Vector2)">
            <summary>
            Normalizes the given vector
            </summary>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="M:WinterRose.Vectors.Vector2.GetLength">
            <summary>
            Gets the length of this vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:WinterRose.Vectors.Vector2.GetLengthSquared">
            <summary>
            Gets the length of this vector squared
            </summary>
            <returns></returns>
        </member>
        <member name="M:WinterRose.Vectors.Vector2.Dot(WinterRose.Vectors.Vector2,WinterRose.Vectors.Vector2)">
            <summary>
            Creates a dot product with the given vectors
            </summary>
            <param name="value1"></param>
            <param name="value2"></param>
            <returns></returns>
        </member>
        <member name="M:WinterRose.Vectors.Vector2.Lerp(WinterRose.Vectors.Vector2,WinterRose.Vectors.Vector2,System.Single)">
            <summary>
            Lerps the given vectors to the given amount of time
            </summary>
            <param name="start"></param>
            <param name="end"></param>
            <param name="time"></param>
            <returns>The lerped Vector2</returns>
        </member>
        <member name="M:WinterRose.Vectors.Vector2.Clone">
            <summary>
            Clones this vector2
            </summary>
            <returns></returns>
        </member>
        <member name="M:WinterRose.Vectors.Vector2.Equals(WinterRose.Vectors.Vector2)">
            <summary>
            Checks if the given vector2 is equals to this one
            </summary>
            <param name="other"></param>
            <returns>true if it is, otherwise false</returns>
        </member>
        <member name="M:WinterRose.Vectors.Vector2.GetHashCode">
            <summary>
            Gets the hashcode for this object
            </summary>
            <returns>This objects hashcode</returns>
        </member>
        <member name="M:WinterRose.Vectors.Vector2.Equals(System.Object)">
            <summary>
            Checks if the given vector2 is equals to this one
            </summary>
            <param name="other"></param>
            <returns>true if it is, otherwise false</returns>
        </member>
        <member name="M:WinterRose.Vectors.Vector2.op_Addition(WinterRose.Vectors.Vector2,WinterRose.Vectors.Vector2)">
            <summary>
            Adds 2 Vector2 together
            </summary>
            <returns>a new vector2 where the 2 values are added together</returns>
        </member>
        <member name="M:WinterRose.Vectors.Vector2.op_Addition(WinterRose.Vectors.Vector2,System.Single)">
            <summary>
            adds a float value to a vector2
            </summary>
            <returns>a new vector2 where the float has been added to the original values</returns>
        </member>
        <member name="M:WinterRose.Vectors.Vector2.op_Subtraction(WinterRose.Vectors.Vector2,WinterRose.Vectors.Vector2)">
            <summary>
            subtracts 2 Vector2 from eachother
            </summary>
            <returns>a new vector2 where the 2 values are subtracted</returns>
        </member>
        <member name="M:WinterRose.Vectors.Vector2.op_Subtraction(WinterRose.Vectors.Vector2,System.Single)">
            <summary>
            subtracts a float value from a vector2
            </summary>
            <returns>a new vector2 where the float has been subtracted from the original values</returns>
        </member>
        <member name="M:WinterRose.Vectors.Vector2.op_Division(WinterRose.Vectors.Vector2,WinterRose.Vectors.Vector2)">
            <summary>
            devides the values of 2 vector2
            </summary>
            <returns>a new vector2 where the values have been diveded with eachother</returns>
        </member>
        <member name="M:WinterRose.Vectors.Vector2.op_Division(WinterRose.Vectors.Vector2,System.Single)">
            <summary>
            devides the values of a vector2 with a float
            </summary>
            <returns>a new vector2 where the values are devided by the float</returns>
        </member>
        <member name="M:WinterRose.Vectors.Vector2.op_Multiply(WinterRose.Vectors.Vector2,WinterRose.Vectors.Vector2)">
            <summary>
            multiplies the values together
            </summary> 
            <returns>a new vector2 where the values are multiplied by eachother</returns>
        </member>
        <member name="M:WinterRose.Vectors.Vector2.op_Multiply(WinterRose.Vectors.Vector2,System.Single)">
            <summary>
            multiplies the values by a float
            </summary>
            <returns>a new vector2 where the values are multiplied by the float</returns>
        </member>
        <member name="M:WinterRose.Vectors.Vector2.op_Modulus(WinterRose.Vectors.Vector2,WinterRose.Vectors.Vector2)">
            <summary>
            makes a new vector3 with the remainders of a devision
            </summary>
            <returns>a new vector2 with the remainders of a devision as its values</returns>
        </member>
        <member name="M:WinterRose.Vectors.Vector2.op_Modulus(WinterRose.Vectors.Vector2,System.Single)">
             <summary></summary>
            <returns>a new vector2 where the values are the remainers of a division</returns>
        </member>
        <member name="M:WinterRose.Vectors.Vector2.op_GreaterThan(WinterRose.Vectors.Vector2,WinterRose.Vectors.Vector2)">
            <summary></summary>
            <returns>true if left value is greater than the right value</returns>
        </member>
        <member name="M:WinterRose.Vectors.Vector2.op_LessThan(WinterRose.Vectors.Vector2,WinterRose.Vectors.Vector2)">
            <summary></summary>
            <returns>true if right value is greater than the left value</returns>
        </member>
        <member name="M:WinterRose.Vectors.Vector2.op_GreaterThan(WinterRose.Vectors.Vector2,System.Single)">
            <summary></summary>
            <returns>true if left value is greater than the right value</returns>
        </member>
        <member name="M:WinterRose.Vectors.Vector2.op_LessThan(WinterRose.Vectors.Vector2,System.Single)">
            <summary></summary>
            <returns>true if right value is greater than the left value</returns>
        </member>
        <member name="M:WinterRose.Vectors.Vector2.op_GreaterThanOrEqual(WinterRose.Vectors.Vector2,WinterRose.Vectors.Vector2)">
            <summary></summary>
            <returns>true if left value is greater than, or equal the right value</returns>
        </member>
        <member name="M:WinterRose.Vectors.Vector2.op_LessThanOrEqual(WinterRose.Vectors.Vector2,WinterRose.Vectors.Vector2)">
            <summary></summary>
            <returns>true if right value is greater than, or equal the left value</returns>
        </member>
        <member name="M:WinterRose.Vectors.Vector2.op_Equality(WinterRose.Vectors.Vector2,WinterRose.Vectors.Vector2)">
            <summary></summary>
            <returns>Returns true if <paramref name="v1"/> its values are identical to <paramref name="v2"/></returns>
        </member>
        <member name="M:WinterRose.Vectors.Vector2.op_Inequality(WinterRose.Vectors.Vector2,WinterRose.Vectors.Vector2)">
            <summary></summary>
            <returns>Returns true if <paramref name="v1"/> its values are identical to <paramref name="v2"/></returns>
        </member>
        <member name="T:WinterRose.Vectors.Vector3">
            <summary>
            An object that represents a position in 3D worldspace
            </summary>
        </member>
        <member name="F:WinterRose.Vectors.Vector3.x">
            <summary>
            Vector3 coördinate
            </summary>
        </member>
        <member name="F:WinterRose.Vectors.Vector3.y">
            <summary>
            Vector3 coördinate
            </summary>
        </member>
        <member name="F:WinterRose.Vectors.Vector3.z">
            <summary>
            Vector3 coördinate
            </summary>
        </member>
        <member name="M:WinterRose.Vectors.Vector3.#ctor(System.Single,System.Single,System.Single)">
            <summary>
            poppulation constructor
            </summary>
            <param name="x">x</param>
            <param name="y">y</param>
            <param name="z">z</param>
        </member>
        <member name="M:WinterRose.Vectors.Vector3.#ctor">
            <summary>
            empty constructor
            </summary>
        </member>
        <member name="M:WinterRose.Vectors.Vector3.ToString">
            <summary>
            Returns a string representation of the Vector3
            </summary>
            <returns></returns>
        </member>
        <member name="M:WinterRose.Vectors.Vector3.Random(System.Int32,System.Int32)">
            <summary>
            generates a vector3 with random values
            </summary>
            <returns>new vector3 where the values xyz are randomized</returns>
        </member>
        <member name="M:WinterRose.Vectors.Vector3.Distance(WinterRose.Vectors.Vector3,WinterRose.Vectors.Vector3)">
            <summary>
            gets the distance between 2 vector3 points
            </summary>
            <returns>a float with the distance between the 2 points in a straight line</returns>
        </member>
        <member name="M:WinterRose.Vectors.Vector3.op_Addition(WinterRose.Vectors.Vector3,WinterRose.Vectors.Vector3)">
            <summary>
            Adds 2 Vector3 together
            </summary>
            <returns>a new vector3 where the 2 values are added together</returns>
        </member>
        <member name="M:WinterRose.Vectors.Vector3.op_Addition(WinterRose.Vectors.Vector3,System.Single)">
            <summary>
            adds a float value to a vector3
            </summary>
            <returns>a new vector3 where the float has been added to the original values</returns>
        </member>
        <member name="M:WinterRose.Vectors.Vector3.op_Subtraction(WinterRose.Vectors.Vector3,WinterRose.Vectors.Vector3)">
            <summary>
            subtracts 2 Vector3 from eachother
            </summary>
            <returns>a new vector3 where the 2 values are subtracted</returns>
        </member>
        <member name="M:WinterRose.Vectors.Vector3.op_Subtraction(WinterRose.Vectors.Vector3,System.Single)">
            <summary>
            subtracts a float value from a vector3
            </summary>
            <returns>a new vector3 where the float has been subtracted from the original values</returns>
        </member>
        <member name="M:WinterRose.Vectors.Vector3.op_Division(WinterRose.Vectors.Vector3,WinterRose.Vectors.Vector3)">
            <summary>
            devides the values of 2 vector3
            </summary>
            <returns>a new vector3 where the values have been diveded with eachother</returns>
        </member>
        <member name="M:WinterRose.Vectors.Vector3.op_Division(WinterRose.Vectors.Vector3,System.Single)">
            <summary>
            devides the values of a vector3 with a float
            </summary>
            <returns>a new vector3 where the values are devided by the float</returns>
        </member>
        <member name="M:WinterRose.Vectors.Vector3.op_Multiply(WinterRose.Vectors.Vector3,WinterRose.Vectors.Vector3)">
            <summary>
            multiplies the values together
            </summary>
            <returns>a new vector3 where the values are multiplied by eachother</returns>
        </member>
        <member name="M:WinterRose.Vectors.Vector3.op_Multiply(WinterRose.Vectors.Vector3,System.Single)">
            <summary>
            multiplies the values by a float
            </summary>
            <returns>a new vector3 where the values are multiplied by the float</returns>
        </member>
        <member name="M:WinterRose.Vectors.Vector3.op_Modulus(WinterRose.Vectors.Vector3,WinterRose.Vectors.Vector3)">
            <summary>
            makes a new vector3 with the remainders of a devision
            </summary>
            <returns>a new vector3 where the values are the remainers of a division</returns>
        </member>
        <member name="M:WinterRose.Vectors.Vector3.op_Modulus(WinterRose.Vectors.Vector3,System.Single)">
             <summary>
             makes a new vector3 with the remainders of a devision
             </summary>
            <returns>a new vector3 where the values are the remainers of a division</returns>
        </member>
        <member name="M:WinterRose.Vectors.Vector3.op_GreaterThan(WinterRose.Vectors.Vector3,WinterRose.Vectors.Vector3)">
            <summary></summary>
            <returns>true if left value is greater than the right value</returns>
        </member>
        <member name="M:WinterRose.Vectors.Vector3.op_LessThan(WinterRose.Vectors.Vector3,WinterRose.Vectors.Vector3)">
            <summary></summary>
            <returns>true if right value is greater than the left value</returns>
        </member>
        <member name="M:WinterRose.Vectors.Vector3.op_GreaterThan(WinterRose.Vectors.Vector3,System.Single)">
            <summary></summary>
            <returns>true if left value is greater than the right value</returns>
        </member>
        <member name="M:WinterRose.Vectors.Vector3.op_LessThan(WinterRose.Vectors.Vector3,System.Single)">
            <summary></summary>
            <returns>true if right value is greater than the left value</returns>
        </member>
        <member name="M:WinterRose.Vectors.Vector3.op_GreaterThanOrEqual(WinterRose.Vectors.Vector3,WinterRose.Vectors.Vector3)">
            <summary></summary>
            <returns>true if left value is greater than, or equal the right value</returns>
        </member>
        <member name="M:WinterRose.Vectors.Vector3.op_LessThanOrEqual(WinterRose.Vectors.Vector3,WinterRose.Vectors.Vector3)">
            <summary></summary>
            <returns>true if right value is greater than, or equal the left value</returns>
        </member>
        <member name="T:WinterRose.WIP.Redis.RedisAnswer`1">
            <summary>
            Provides an easy way of telling the result of the Redis response
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:WinterRose.WIP.Redis.RedisAnswer`1.Value">
            <summary>
            The value that was returned by the Redis server
            </summary>
        </member>
        <member name="P:WinterRose.WIP.Redis.RedisAnswer`1.HasValue">
            <summary>
            Indicates if this answer has a valid value
            </summary>
        </member>
        <member name="M:WinterRose.WIP.Redis.RedisAnswer`1.op_Implicit(WinterRose.WIP.Redis.RedisAnswer{`0})~`0">
            <summary>
            Implicidly converts the RedisAnswer to its value
            </summary>
            <param name="answer"></param>
        </member>
        <member name="P:WinterRose.WIP.Redis.Framework.RedisConnectionBase.IsConnected">
            <summary>
            Returns if the current connection is linked to Redis
            </summary>
        </member>
        <member name="T:WinterRose.WIP.Redis.RedisConnection">
            <summary>
            A class object that provides methods to communicate with a Redis database
            </summary>
        </member>
        <member name="P:WinterRose.WIP.Redis.RedisConnection.IsConnected">
            <summary>
            Gets whether there is a valid connection to Redis
            </summary>
        </member>
        <member name="M:WinterRose.WIP.Redis.RedisConnection.#ctor">
            <summary>
            Creates an instance of this class. This constructor does not automatically connect to a Redis server.
            </summary>
        </member>
        <member name="M:WinterRose.WIP.Redis.RedisConnection.#ctor(System.String,System.Int32)">
            <summary>
            Creates an instance if the RedisConnection class, and tries to establish a connection with the given host and port
            </summary>
            <param name="host"></param>
            <param name="port"></param>
        </member>
        <member name="M:WinterRose.WIP.Redis.RedisConnection.#ctor(System.String,System.Int32,System.String)">
            <summary>
            Creates an instance if the RedisConnection class, and tries to establish a connection with the given host and port. then if the connection established successfully, attempts to authenticate with the given password
            </summary>
            <param name="host"></param>
            <param name="port"></param>
        </member>
        <member name="M:WinterRose.WIP.Redis.RedisConnection.MakeConnection(System.String,System.Int32)">
            <summary>
            Attempts to make a connection to Redis with the given host and port
            </summary>
            <param name="host"></param>
            <param name="port"></param>
            <returns>A RedisAnswer containing a bool of true if the connection was established, or false if it was not</returns>
        </member>
        <member name="M:WinterRose.WIP.Redis.RedisConnection.EndConnection">
            <summary>
            Ends a connection to Redis if there is one
            </summary>
        </member>
        <member name="M:WinterRose.WIP.Redis.RedisConnection.DeleteKeys``1(``0[])">
            <summary>
            Deletes the given keys from the database
            </summary>
            <typeparam name="K"></typeparam>
            <param name="keys"></param>
            <returns>The number of keys successfully deleted</returns>
        </member>
        <member name="M:WinterRose.WIP.Redis.RedisConnection.GetKeysByPattern(System.String)">
            <summary>
            Gets the keys that match the pattern. Use " <b>*</b> " to get all keys
            </summary>
            <param name="pattern"></param>
            <returns></returns>
        </member>
        <member name="M:WinterRose.WIP.Redis.RedisConnection.GetRandomKey">
            <summary>
            Gets a random key from Redis
            </summary>
            <returns></returns>
        </member>
        <member name="M:WinterRose.WIP.Redis.RedisConnection.GetKeyTimeout``1(``0)">
            <summary>
            Returns the timeout for the specified key in seconds
            </summary>
        </member>
        <member name="M:WinterRose.WIP.Redis.RedisConnection.KeyExists``1(``0)">
            <summary>
            Checks if the given key exists within the database
            </summary>
            <returns>True if the key exists, else false</returns>
        </member>
        <member name="M:WinterRose.WIP.Redis.RedisConnection.RenameKey``2(``0,``1)">
            <summary>
            Renames the given key to the specified new name
            </summary>
            <typeparam name="K1"></typeparam>
            <typeparam name="K2"></typeparam>
            <param name="key"></param>
            <param name="newKey"></param>
            <returns>StatusCode.OK if succeeded, otherwise StatusCode.Faulted</returns>
        </member>
        <member name="M:WinterRose.WIP.Redis.RedisConnection.GetKeyType``1(``0)">
            <summary>
            Gets the type of the key
            </summary>
            <typeparam name="K"></typeparam>
            <param name="key"></param>
            <returns>the <see cref="T:WinterRose.WIP.Redis.Utils.KeyType"/> of the given key</returns>
        </member>
        <member name="M:WinterRose.WIP.Redis.RedisConnection.SetKeyExpiry``1(``0,System.Int32)">
            <summary>
            Sets the expiration time of the given key at the given amount of seconds
            </summary>
            <typeparam name="K"></typeparam>
            <param name="key"></param>
            <param name="timeoutInSeconds"></param>
            <returns>true if the operation succeeded, false if not</returns>
        </member>
        <member name="M:WinterRose.WIP.Redis.RedisConnection.RemoveTimeout``1(``0)">
            <summary>
            Removes the timeout of the given key
            </summary>
            <typeparam name="K"></typeparam>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:WinterRose.WIP.Redis.RedisConnection.Get``2(``1)">
            <summary>
            Gets the value at the given key
            </summary>
            <returns>The value at the key</returns>
        </member>
        <member name="M:WinterRose.WIP.Redis.RedisConnection.Set``2(``0,``1)">
            <summary>
            Sets the given key to the given value
            </summary>
            <returns><see cref="F:WinterRose.WIP.Redis.RedisAnswerStatusCode.OK"/> if the operation succeeded, else <see cref="F:WinterRose.WIP.Redis.RedisAnswerStatusCode.Faulted"/></returns>
        </member>
        <member name="M:WinterRose.WIP.Redis.RedisConnection.Append``2(``0,``1)">
            <summary>
            Appends the <paramref name="val"/> to the specified key's existing value.
            </summary>
            <returns>The length of the final apended string.</returns>
        </member>
        <member name="M:WinterRose.WIP.Redis.RedisConnection.GetSet``3(``1,``2)">
            <summary>
            Gets the value of the given key, then overrides it with the new value
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="K"></typeparam>
            <typeparam name="V"></typeparam>
            <param name="key"></param>
            <param name="val"></param>
            <returns>the value that was found</returns>
        </member>
        <member name="M:WinterRose.WIP.Redis.RedisConnection.GetMultiple``2(``1[])">
            <summary>
            Gets the values of multiple keys at the same time
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="K"></typeparam>
            <param name="keys"></param>
            <returns>an array of all the values</returns>
        </member>
        <member name="M:WinterRose.WIP.Redis.RedisConnection.SetKeyWithExpiry``2(``0,System.Int32,``1)">
            <summary>
            Sets the key with an immidiate expire time of the specified number of seconds
            </summary>
            <returns><see cref="F:WinterRose.WIP.Redis.RedisAnswerStatusCode.OK"/> if succeeded, else <see cref="F:WinterRose.WIP.Redis.RedisAnswerStatusCode.Faulted"/></returns>
        </member>
        <member name="M:WinterRose.WIP.Redis.RedisConnection.Dispose">
            <summary>
            Disposes this connection by closing it.
            </summary>
        </member>
        <member name="M:WinterRose.WIP.Redis.RedisConnection.Authenticate(System.String)">
            <summary>
            Authenticates the established connection
            </summary>
            <param name="password"></param>
            <returns></returns>
        </member>
        <member name="M:WinterRose.WIP.Redis.RedisConnection.Ping">
            <summary>
            Pings the database and checks whether it is accessable
            </summary>
            <returns><see cref="F:WinterRose.WIP.Redis.RedisAnswerStatusCode.Pong"/> if the database is reached, else <see cref="F:WinterRose.WIP.Redis.RedisAnswerStatusCode.Undefined"/> with a <see cref="P:WinterRose.WIP.Redis.RedisAnswer`1.HasValue"/> set to false</returns>
        </member>
        <member name="M:WinterRose.WIP.Redis.RedisConnection.Close">
            <summary>
            Connection is closed as soon as all the pending replies are written to the client.
            </summary>
        </member>
        <member name="M:WinterRose.WIP.Redis.RedisConnection.GetDBSize">
            <summary>
            Gets the size of the database in bytes
            </summary>
            <returns></returns>
        </member>
        <member name="M:WinterRose.WIP.Redis.RedisConnection.SetExpireAt``1(``0,System.Int32)">
            <summary>
            Sets the expiry for the specified key.
            timeout is specified in unix timestamp i.e. seconds since January 1, 1970.
            </summary>
            <returns>
            True if the operation succeeded, false if not
            </returns>
        </member>
        <member name="M:WinterRose.WIP.Redis.RedisConnection.ListPopLeftBlocking(System.Int32,System.String[])">
            <summary>
            Returns the left most element of the first non-empty list encountered.
            If all of the specified lists are empty, the connection is blocked until an element
            is inserted using LPUSH or RPUSH or timeout expires.
            A timeout of zero can be used to block indefinitely.
            </summary>
            <returns>
            The pop left blocking.
            </returns>
            <param name='timeoutSeconds'>
            Timeout seconds.
            </param>
            <param name='keys'>
            Keys.
            </param>
        </member>
        <member name="M:WinterRose.WIP.Redis.RedisConnection.ListPopRightBlocking(System.Int32,System.String[])">
            <summary>
            Returns the right most element of the first non-empty list encountered.
            If all of the specified lists are empty, the connection is blocked until an element
            is inserted using LPUSH or RPUSH or timeout expires.
            A timeout of zero can be used to block indefinitely.
            </summary>
            <returns>
            The pop right blocking.
            </returns>
            <param name='timeoutSeconds'>
            Timeout seconds.
            </param>
            <param name='keys'>
            Keys.
            </param>
        </member>
        <member name="M:WinterRose.WIP.Redis.RedisConnection.Flush">
            <summary>
            <b>WARNING</b>. This will delete <b><em>every</em></b> entry within your database. Use with caution
            </summary>
            <returns><see cref="F:WinterRose.WIP.Redis.RedisAnswerStatusCode.OK"/> if the operation succeeded. else <see cref="F:WinterRose.WIP.Redis.RedisAnswerStatusCode.Faulted"/></returns>
        </member>
        <member name="F:WinterRose.WIP.Redis.RedisAnswerStatusCode.Undefined">
            <summary>
            An undefined answer statuscode
            </summary>
        </member>
        <member name="F:WinterRose.WIP.Redis.RedisAnswerStatusCode.OK">
            <summary>
            This is returned from the database when the requested operation completed successfully
            </summary>
        </member>
        <member name="F:WinterRose.WIP.Redis.RedisAnswerStatusCode.Faulted">
            <summary>
            This is returned from the database when the requested operation failed to complete
            </summary>
        </member>
        <member name="F:WinterRose.WIP.Redis.RedisAnswerStatusCode.Pong">
            <summary>
            Gets returned when <see cref="M:WinterRose.WIP.Redis.RedisConnection.Ping"></see> is called and a connection is established
            </summary>
        </member>
        <member name="T:WinterRose.WIP.ReflectionTests.ReflectionTests">
            <summary>
            Random tests for reflection.
            </summary>
        </member>
    </members>
</doc>
